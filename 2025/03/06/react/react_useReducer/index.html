<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>React v17 源码系列：一文搞懂 useReducer | Neil&#39;s Blog</title>
    <meta name="author" content="Neil Ji" />
    <meta name="keywords" content="react,js,javascript,react17.0.2,ts,typescript,redux,mobx" />
    <meta name="description" content="前瞻本文将介绍 useReducer 的核心机制，在阅读之前，推荐先大致了解 React Reconcile 机制，想要从本文获益的话，至少应当理解 React Fiber, Work Loop, 单向、循环链表数据结构的概念，关于 React 源码解析可参考我的另一篇文章：React v17 源码解析由于 React Hook 的复杂度较高，读一遍文章就想建立起结构化记忆是很困难的，所以我推荐先了解以下核心机制，待熟悉后，再参考我给出的完整代码，把以下概念串联起来：Mount 与 Update" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    <link rel="alternate" href="/atom.xml" title="Neil&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    
<link rel="stylesheet" href="/css/style.css">


    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
<meta name="generator" content="Hexo 6.3.0"></head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">Neil&#39;s Blog</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <!-- <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://neil-ji.github.io"></form> -->

        
            
                
                    

                        
                            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%9E%BB"><span class="toc-number">1.</span> <span class="toc-text">前瞻</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mount-VS-Update"><span class="toc-number">2.</span> <span class="toc-text">Mount VS Update</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReactCurrentDispatcher-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%A8%E5%85%A5"><span class="toc-number">3.</span> <span class="toc-text">ReactCurrentDispatcher 运行时注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hook-%E5%AF%B9%E8%B1%A1%E4%B8%8E-currentHook-amp-workInProgressHook"><span class="toc-number">4.</span> <span class="toc-text">Hook 对象与 currentHook &amp; workInProgressHook</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fiber-%E4%B8%8E-Hook"><span class="toc-number">5.</span> <span class="toc-text">Fiber 与 Hook</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Update-Queue-%E4%B8%8E-queue-base-amp-queue-pending"><span class="toc-number">6.</span> <span class="toc-text">Update Queue 与 queue.base &amp; queue.pending</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lane-%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">Lane 模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%EF%BC%9AdispatchAction"><span class="toc-number">8.</span> <span class="toc-text">触发组件更新：dispatchAction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Final-Boss%EF%BC%9AuseReducerOnMount-amp-useReducerOnUpdate"><span class="toc-number">9.</span> <span class="toc-text">Final Boss：useReducerOnMount &amp; useReducerOnUpdate</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4-Mock-%E4%BB%A3%E7%A0%81"><span class="toc-number">10.</span> <span class="toc-text">完整 Mock 代码</span></a></li></ol>
                                
    </div>
</aside>
</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            React v17 源码系列：一文搞懂 useReducer
        </h1>
        
        <div class="article-meta clearfix">
            
            <a class="article-date" href="/archives/2025/03/06">
    
    <i class="icon-calendar vm"></i>
    
    
        <span class="vm">Created at</span>
    
    <time class="vm" datetime="2025-03-06T16:00:00.000Z" itemprop="datePublished">2025-03-07</time>
</a>

            <div class="article-updated">
    
    <i class="icon-calendar vm"></i>
    
    
        <span class="vm">Modified at</span>
    
    <time class="vm" datetime="2025-03-07T09:26:13.916Z" itemprop="datePublished">2025-03-07</time>
</div>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/react/" rel="tag">react</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        <div>
            
            
                
            
            
                <h1 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h1><p>本文将介绍 useReducer 的核心机制，在阅读之前，推荐先大致了解 React Reconcile 机制，想要从本文获益的话，至少应当理解 <strong>React Fiber, Work Loop, 单向、循环链表数据结构</strong>的概念，关于 React 源码解析可参考我的另一篇文章：<a href="/2023/05/31/react/reactcode17.0.2">React v17 源码解析</a></p>
<p>由于 React Hook 的复杂度较高，读一遍文章就想建立起结构化记忆是很困难的，所以我推荐先了解以下核心机制，待熟悉后，再参考我给出的完整代码，把以下概念串联起来：</p>
<ol>
<li>Mount 与 Update 的区别</li>
<li>ReactCurrentDispatcher 运行时注入</li>
<li>Hook 对象与两个单向链表：currentHook &amp; workInProgressHook</li>
<li>Fiber 与 Hook 的联系</li>
<li>Update Queue 与两个循环链表：base &amp; pending</li>
<li>Lane 模型</li>
<li>更新触发：dispatch</li>
<li>useReducerOnMount &amp; useReducerOnUpdate</li>
</ol>
<h1 id="Mount-VS-Update"><a href="#Mount-VS-Update" class="headerlink" title="Mount VS Update"></a>Mount VS Update</h1><p>React Hook 在组件 Mount 和 Update 阶段的逻辑是不同的，我们暂且称之为 <code>useReducerOnMount</code> 和<code>useReducerOnUpdate</code>，为了避免一上来就 Deep Dive 吓退读者，让我们暂且忽略二者的细节吧，对这两个函数仅做简单介绍，后文我会给出完整代码以供参考。</p>
<p>Mount 阶段，useReducer 所做的事，相对来说很简单：</p>
<ol>
<li>创建 Hook 对象</li>
<li>构建单向链表 workInProgressHook</li>
<li>计算初始状态</li>
<li>bind dispatch 回调函数</li>
</ol>
<p>Update 阶段，稍微复杂一些：</p>
<ol>
<li>克隆 Hook 对象</li>
<li>构建单向链表 currentHook</li>
<li>构建单向链表 workInProgressHook</li>
<li>检查前后两次渲染 Hook 调用次数是否一致</li>
<li>处理 Update Queue</li>
</ol>
<h1 id="ReactCurrentDispatcher-运行时注入"><a href="#ReactCurrentDispatcher-运行时注入" class="headerlink" title="ReactCurrentDispatcher 运行时注入"></a>ReactCurrentDispatcher 运行时注入</h1><p>讲完了 <code>useReducerOnMount</code> 和<code>useReducerOnUpdate</code>，引出我们的第一个问题，这二者是如何导出为一个 Hook 函数 <code>useReducer</code> 的呢？</p>
<p>答案就是 ReactCurrentDispatcher 机制。我们先来看下这段代码，这是一段省略了部分函数调用的 React useReducer 源码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher 包含了所有 Hook 的实现细节</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactCurrentDispatcher</span>: <span class="built_in">any</span> = &#123;</span><br><span class="line">  <span class="attr">current</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Dispatcher</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveDispatcher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMockReducer</span>(<span class="params">reducer, initialArgs, init?</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useReducer</span>(reducer, initialArgs, init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有点感觉了吗？其实就是通过一个闭包全局变量 ReactCurrentDispatcher 实现的运行时注入。</p>
<p>具体来讲，在 reconcile 阶段，函数组件会通过 <code>renderWithHook</code> 函数进行 reconcile，ReactCurrentDispatcher.current 的引用替换就发生在此时此处：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current === <span class="literal">null</span> || current.<span class="property">memorizedState</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">HooksDispatcherOnMount</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">HooksDispatcherOnUpdate</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="title class_">Component</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>上述代码段执行后，ReactCurrentDispatcher.current 就指向了 Mount 或 Update 阶段 Hooks 的底层实现，调用过程：renderWithHook -&gt; Component -&gt; useReducer -&gt; ReactCurrentDispatcher.current.useReducer</p>
<p>关于 reconcile 与 renderWithHook 可以查看我的另一篇文章：<a href="/2023/05/31/react/reactcode17.0.2">React v17 源码解析</a></p>
<h1 id="Hook-对象与-currentHook-amp-workInProgressHook"><a href="#Hook-对象与-currentHook-amp-workInProgressHook" class="headerlink" title="Hook 对象与 currentHook &amp; workInProgressHook"></a>Hook 对象与 currentHook &amp; workInProgressHook</h1><h1 id="Fiber-与-Hook"><a href="#Fiber-与-Hook" class="headerlink" title="Fiber 与 Hook"></a>Fiber 与 Hook</h1><h1 id="Update-Queue-与-queue-base-amp-queue-pending"><a href="#Update-Queue-与-queue-base-amp-queue-pending" class="headerlink" title="Update Queue 与 queue.base &amp; queue.pending"></a>Update Queue 与 queue.base &amp; queue.pending</h1><h1 id="Lane-模型"><a href="#Lane-模型" class="headerlink" title="Lane 模型"></a>Lane 模型</h1><h1 id="触发组件更新：dispatchAction"><a href="#触发组件更新：dispatchAction" class="headerlink" title="触发组件更新：dispatchAction"></a>触发组件更新：dispatchAction</h1><h1 id="Final-Boss：useReducerOnMount-amp-useReducerOnUpdate"><a href="#Final-Boss：useReducerOnMount-amp-useReducerOnUpdate" class="headerlink" title="Final Boss：useReducerOnMount &amp; useReducerOnUpdate"></a>Final Boss：useReducerOnMount &amp; useReducerOnUpdate</h1><h1 id="完整-Mock-代码"><a href="#完整-Mock-代码" class="headerlink" title="完整 Mock 代码"></a>完整 Mock 代码</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前正在渲染的 fiber 节点</span></span><br><span class="line"><span class="keyword">let</span> currentlyRenderingFiber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在处理的 Hook 节点</span></span><br><span class="line"><span class="keyword">let</span> workInProgressHook;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上次 render 后处理完毕的 Hook 节点</span></span><br><span class="line"><span class="keyword">let</span> currentHook;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook 节点初始化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountWorkInProgressHook</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 初始化 hook 对象</span></span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    <span class="attr">memorizedState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 2. 维护 hooks 链表</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.1 首次执行，把当前 hook 节点，保存到当前正在渲染的 fiber 节点上</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">memorizedState</span> = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2 非首次执行，维护 hooks 链表即可：当前 hook 节点 append 到 hooks 链表</span></span><br><span class="line">    workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 将 hook 节点标记为正在处理</span></span><br><span class="line">  workInProgressHook = hook;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook 节点复用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateWorkInProgressHook</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 确定 currentHook 节点来源</span></span><br><span class="line">  <span class="keyword">let</span> nextCurrentHook;</span><br><span class="line">  <span class="keyword">if</span> (currentHook == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.1 说明是首次 Update，直接复用 alternate fiber 上保存的 hook 节点（此处做了简化，实际还要判断 alternate 是否为空）</span></span><br><span class="line">    nextCurrentHook = currentlyRenderingFiber.<span class="property">alternate</span>.<span class="property">memorizedState</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 1.2 说明不是首次 Update，那么直接复用 currentHook.next</span></span><br><span class="line">    nextCurrentHook = currentHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 确定 workInProgressHook 节点来源</span></span><br><span class="line">  <span class="keyword">let</span> nextWorkInProgressHook;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.1 说明这是组件中调用的首个 Hook（仔细体会跟 Case 1.1 的区别），直接复用 current fiber 上保存的 hook 节点（一般来说，就是 alternate 上的 hook 节点）</span></span><br><span class="line">    nextWorkInProgressHook = currentlyRenderingFiber.<span class="property">memorizedState</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2 说明这并非组件中调用的首个 Hook，那么直接复用 workInProgressHook.next</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 找到下个要处理的 Hook</span></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 3.1 既然 nextWorkInProgress 有值，那就将 nextWorkInProgress 标记为处理中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1.1 把 next 指向的 hook 标记为处理中</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    <span class="comment">// 3.1.2 再移动链表指针 next 到下个节点</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3.2 说明 workInProgressHook 链表还没创建，此时克隆  currentHook 节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.1 对于 Hook 来说，current 和 workInProgress 总是成对出现，此处既然 workInProgress 存在，</span></span><br><span class="line">    <span class="comment">// 那么 current 也必须存在，否则就说明这次将要处理的 hook 数量比上次 render 已处理完毕的 hook 数量要多，给出警告！</span></span><br><span class="line">    <span class="keyword">if</span> (nextCurrentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Rendered more hooks than during the previous render.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.2 克隆 currentHook 节点</span></span><br><span class="line">    <span class="keyword">const</span> newHook = &#123;</span><br><span class="line">      <span class="attr">memoizedState</span>: currentHook.<span class="property">memoizedState</span>,</span><br><span class="line">      <span class="attr">baseState</span>: currentHook.<span class="property">baseState</span>,</span><br><span class="line">      <span class="attr">baseQueue</span>: currentHook.<span class="property">baseQueue</span>,</span><br><span class="line">      <span class="attr">queue</span>: currentHook.<span class="property">queue</span>,</span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.3 维护 Hook 链表结构</span></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 3.2.3.1 newHook 置为头结点</span></span><br><span class="line">      currentlyRenderingFiber.<span class="property">memorizedState</span> = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3.2.3.2 newHook 附加到链表尾</span></span><br><span class="line">      workInProgressHook.<span class="property">next</span> = newHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.4 标记 newHook 为处理中</span></span><br><span class="line">    workInProgressHook = newHook;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 移动 currentHook 链表指针到下个节点（此处简化，实际代码是在步骤 3 中完成的）</span></span><br><span class="line">  currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 返回被标记为处理中的 hook 节点</span></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发更新时会调用该函数，类组件的 setState 也会调用该函数，重新 render、commit</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduleUpdateOnFiber</span>(<span class="params">fiber</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为交互事件中触发的更新</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInterleavedUpdate</span>(<span class="params">fiber</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交互事件中触发的更新会被维护在一个队列中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushInterleavedQueue</span>(<span class="params">queue</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch 函数，每次执行生成一个 update 节点，这些节点会以循环链表形式，被维护在 Update Queue 的 pending 或 interleaved 属性上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAction</span>(<span class="params">fiber, queue, action</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 初始化 update 节点</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">update</span>: <span class="built_in">any</span> = &#123;</span><br><span class="line">    action,</span><br><span class="line">    <span class="attr">eagerReducer</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">eagerState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 维护 updates 循环链表</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isInterleavedUpdate</span>(fiber)) &#123;</span><br><span class="line">    <span class="comment">// 2.1 交互事件中触发的更新，维护到 queue.interleaved，这是一个循环链表</span></span><br><span class="line">    <span class="keyword">const</span> interleaved = queue.<span class="property">interleaved</span>;</span><br><span class="line">    <span class="keyword">if</span> (interleaved === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">      update.<span class="property">next</span> = update;</span><br><span class="line">      <span class="comment">// At the end of the current render, this queue&#x27;s interleaved updates will</span></span><br><span class="line">      <span class="comment">// be transfered to the pending queue.</span></span><br><span class="line">      <span class="title function_">pushInterleavedQueue</span>(queue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      update.<span class="property">next</span> = interleaved.<span class="property">next</span>;</span><br><span class="line">      interleaved.<span class="property">next</span> = update;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="property">interleaved</span> = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2 普通更新，维护到 queue.pending，这是一个循环链表</span></span><br><span class="line">    <span class="keyword">const</span> pending = queue.<span class="property">pending</span>;</span><br><span class="line">    <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// This is the first update. Create a circular list.</span></span><br><span class="line">      update.<span class="property">next</span> = update;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      update.<span class="property">next</span> = pending.<span class="property">next</span>;</span><br><span class="line">      pending.<span class="property">next</span> = update;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="property">pending</span> = update;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 执行 reducer</span></span><br><span class="line">  <span class="keyword">const</span> lastRenderedReducer = queue.<span class="property">lastRenderedReducer</span>;</span><br><span class="line">  <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentState = queue.<span class="property">lastRenderedState</span>;</span><br><span class="line">    <span class="comment">// 3.1 reducer 就是这里执行的</span></span><br><span class="line">    <span class="keyword">const</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action);</span><br><span class="line">    <span class="comment">// 3.2 初始化 update 节点的 eagerReducer 和 eagerState</span></span><br><span class="line">    update.<span class="property">eagerReducer</span> = lastRenderedReducer;</span><br><span class="line">    update.<span class="property">eagerState</span> = eagerState;</span><br><span class="line">    <span class="comment">// 3.3 优化：状态没有改变，立即返回，不会进入后续的 render、commit</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">is</span>(currentState, eagerState)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 更新状态，重新 render、commit</span></span><br><span class="line">  <span class="title function_">scheduleUpdateOnFiber</span>(fiber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mount 时调用的 useReducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useReducerOnMount</span>(<span class="params">reducer, initialArgs, init?</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. hook 节点初始化</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 2. 计算初始状态</span></span><br><span class="line">  <span class="keyword">let</span> memorizedState;</span><br><span class="line">  <span class="keyword">if</span> (init) &#123;</span><br><span class="line">    <span class="comment">// 2.1 三参数用法</span></span><br><span class="line">    memorizedState = <span class="title function_">init</span>(initialArgs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2 双参数用法，useState 本质就是执行的这条逻辑分支</span></span><br><span class="line">    memorizedState = initialArgs;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memorizedState</span> = memorizedState;</span><br><span class="line">  <span class="comment">// 3. 初始化 Updates Queue</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">queue</span>: <span class="built_in">any</span> = &#123;</span><br><span class="line">    <span class="comment">// 3.1 这个是普通 update 的循环链表</span></span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 3.2 这个是交互事件触发的 update 的循环链表</span></span><br><span class="line">    <span class="attr">interleaved</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 3.3 这个就是传入的 reducer 函数</span></span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: reducer,</span><br><span class="line">    <span class="comment">// 3.4 这个就是当前状态</span></span><br><span class="line">    <span class="attr">lastRenderedState</span>: memorizedState,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 4. 初始化 dispatch 函数，dispatch 会保持对 currentlyRenderingFiber 和 queue 的引用</span></span><br><span class="line">  queue.<span class="property">dispatch</span> = dispatchAction.<span class="title function_">bind</span>(<span class="literal">null</span>, currentlyRenderingFiber, queue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memorizedState</span>, queue.<span class="property">dispatch</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 时调用的 useReducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useReducerOnUpdate</span>(<span class="params">reducer, initialArgs, init?</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. Hook 复用，无法复用时创建一个新的</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 2. 更新 reducer</span></span><br><span class="line">  hook.<span class="property">queue</span>.<span class="property">lastRenderedReducer</span> = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 合并 baseQueue 和 pendingQueue</span></span><br><span class="line">  <span class="keyword">if</span> (hook.<span class="property">queue</span>.<span class="property">pending</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ... 很复杂，考虑单独去写一篇《Update Queue 机制》</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 遍历 baseQueue，进行状态计算</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook.<span class="property">baseQueue</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ... 很复杂，考虑单独去写一篇《Update Queue 机制》</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 返回的还是 Mount 时创建的 dispatch 回调，</span></span><br><span class="line">  <span class="comment">// 这也是为什么 setState/dispatch 可以安全地从 useEffect/useMemo/useCallback 的依赖列表中移除的原因</span></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memorizedState</span>, hook.<span class="property">queue</span>.<span class="property">dispatch</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatcher 包含了所有 Hook 的实现细节</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactCurrentDispatcher</span>: <span class="built_in">any</span> = &#123;</span><br><span class="line">  <span class="attr">current</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Dispatcher</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveDispatcher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMockReducer</span>(<span class="params">reducer, initialArgs, init?</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useReducer</span>(reducer, initialArgs, init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hooks 宿主对象分为两种，一种是 Mount 时调用，一种 Update 时调用，他的作用就是统一函数名</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span> = &#123;</span><br><span class="line">  <span class="attr">useReducer</span>: useReducerOnMount,</span><br><span class="line">  <span class="comment">// ... other hooks implements</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnUpdate</span> = &#123;</span><br><span class="line">  <span class="attr">useReducer</span>: useReducerOnUpdate,</span><br><span class="line">  <span class="comment">// ... other hooks implements</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在处理的 work unit，这个概念不展开了，去看 React Work Loop 就明白了</span></span><br><span class="line"><span class="keyword">let</span> workInProgress;</span><br><span class="line"><span class="comment">// reconcile 函数组件时会调用该函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">renderWithHooks</span>(<span class="params">current: <span class="built_in">any</span>, Component: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ignore...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 标记当前 work unit 为正在渲染的 fiber 节点，dispatchAction 将保持对该对象的引用（通过bind实现）</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line">  <span class="comment">// 2. ReactCurrentDispatcher 就在这里被赋值为 Hooks 宿主对象</span></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span> || current.<span class="property">memorizedState</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">HooksDispatcherOnMount</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">HooksDispatcherOnUpdate</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 执行函数组件获取 React Element，我们的 useMockReducer 此时就会被执行</span></span><br><span class="line">  <span class="keyword">const</span> child = <span class="title class_">Component</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ignore...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用起来和实际 useReducer 类似</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 首次调用 useMockReducer，将初始化一个 hooks 链表，新建 hook 节点作为头结点</span></span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useMockReducer</span>(</span><br><span class="line">    <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        ...action,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二次调用 useMockReducer，再新建一个 hook 节点，添加到 hooks 链表尾</span></span><br><span class="line">  <span class="keyword">const</span> [state_, setState_] = <span class="title function_">useMockReducer</span>(</span><br><span class="line">    <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        ...action,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                </div>
            
    </section>
</article>




    <a id="pagenext" href="/2025/02/12/tools/filezilla/" class="article-next" title="MacOS 借助 FileZilla 快速部署 FTP Server"><i class="icon-arrow-right"></i></a>






            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>

</body>
</html>
