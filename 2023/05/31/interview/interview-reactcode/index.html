<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>前端进阶（React v17.0.2源码） | Neil&#39;s Blog</title>
    <meta name="author" content="Neil Ji" />
    <meta name="keywords" content="" />
    <meta name="description" content="资源一览React v17.0.2源码在线编辑器（vscode）React v17.0.2源码仓库（github）React内部函数调用关系草图Mount阶段大致如下，可供参考，缩进意为被上一层调用，标记!!!的注释意为核心代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    <link rel="alternate" href="/atom.xml" title="Neil&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    
<link rel="stylesheet" href="/css/style.css">


    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
<meta name="generator" content="Hexo 6.3.0"></head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">Neil&#39;s Blog</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <!-- <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://neil-ji.github.io"></form> -->

        
            
                
                    

                        
                            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E4%B8%80%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">资源一览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E8%8D%89%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">React内部函数调用关系草图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mount%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">Mount基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6Update%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">类组件Update基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%B7%E7%82%B9%E2%80%94%E2%80%94classComponentUpdater"><span class="toc-number">4.1.</span> <span class="toc-text">起点——classComponentUpdater</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%9B%B4%E6%96%B0%E2%80%94%E2%80%94UpdateQueue"><span class="toc-number">4.2.</span> <span class="toc-text">批处理更新——UpdateQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setState%E6%98%AF%E5%BC%82%E6%AD%A5%E8%BF%98%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">setState是异步还是同步的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94scheduleUpdateOnFiber"><span class="toc-number">4.3.</span> <span class="toc-text">开始调度——scheduleUpdateOnFiber</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useState%EF%BC%88%E9%9D%9E%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%BE%85%E4%BF%AE%E6%94%B9%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">useState（非源码实现，待修改）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">6.</span> <span class="toc-text">细节</span></a></li></ol>
                                
    </div>
</aside>
</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            前端进阶（React v17.0.2源码）
        </h1>
        
        <div class="article-meta clearfix">
            
            <a class="article-date" href="/archives/2023/05/31">
    
    <i class="icon-calendar vm"></i>
    
    
        <span class="vm">Created at</span>
    
    <time class="vm" datetime="2023-05-31T07:11:19.000Z" itemprop="datePublished">2023-05-31</time>
</a>

            <div class="article-updated">
    
    <i class="icon-calendar vm"></i>
    
    
        <span class="vm">Modified at</span>
    
    <time class="vm" datetime="2023-07-03T07:53:30.998Z" itemprop="datePublished">2023-07-03</time>
</div>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/" rel="tag">前端进阶</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        <div>
            
            
                
            
            
                <h2 id="资源一览"><a href="#资源一览" class="headerlink" title="资源一览"></a>资源一览</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github1s.com/neil-ji/react/blob/HEAD/packages/">React v17.0.2源码在线编辑器（vscode）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/neil-ji/react/blob/HEAD/packages/">React v17.0.2源码仓库（github）</a></li>
</ul>
<h2 id="React内部函数调用关系草图"><a href="#React内部函数调用关系草图" class="headerlink" title="React内部函数调用关系草图"></a>React内部函数调用关系草图</h2><p>Mount阶段大致如下，可供参考，缩进意为被上一层调用，标记<code>!!!</code>的注释意为核心代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="property">render</span></span><br><span class="line">    legacyRenderSubtreeIntoContainer</span><br><span class="line">        legacyCreateRootFromDOMContainer</span><br><span class="line">            createRoot</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReactDOMRoot</span></span><br><span class="line">                    createRootImpl</span><br><span class="line">                        createContainer </span><br><span class="line">                            createFiberRoot </span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">FiberRootNode</span></span><br><span class="line">                                    createHostRootFiber</span><br><span class="line">                                        createFiber </span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">FiberNode</span></span><br><span class="line">                                            initializeUpdateQueue</span><br><span class="line">        unbatchedUpdates</span><br><span class="line">            updateContainer</span><br><span class="line">                requestEventTime</span><br><span class="line">                requestUpdateLane</span><br><span class="line">                getContextForSubtree</span><br><span class="line">                createUpdate</span><br><span class="line">                enqueueUpdate</span><br><span class="line">                scheduleUpdateOnFiber <span class="comment">// !!! reconcile开始</span></span><br><span class="line">                    markUpdateLaneFromFiberToRoot <span class="comment">// 从当前节点到根节点，依次更新节点的Lane</span></span><br><span class="line">                    markRootUpdated <span class="comment">// 根节点标记为：存在pending update</span></span><br><span class="line">                    performSyncWorkOnRoot <span class="comment">// !!! reconcile开始</span></span><br><span class="line">                        getNextLanes</span><br><span class="line">                        renderRootSync</span><br><span class="line">                            prepareFreshStack <span class="comment">// 初始化Work Loop必需的所有变量</span></span><br><span class="line">                                createWorkInProgress</span><br><span class="line">                                    createFiber</span><br><span class="line">                                enqueueInterleavedUpdates</span><br><span class="line">                            pushDispatcher <span class="comment">// 设置一个ReactCurrentDispatcher，主要用于处理Hooks</span></span><br><span class="line">                            workLoopSync <span class="comment">// !!! 循环处理unitOfWork，正在处理的work称为workInProgress</span></span><br><span class="line">                                performUnitOfWork</span><br><span class="line">                                    beginWork <span class="comment">// !!! 沿child构建Fiber，直到child为null</span></span><br><span class="line">                                        updateHostRoot <span class="comment">// !!! 不同的任务有不同的函数去处理</span></span><br><span class="line">                                            pushHostRootContext</span><br><span class="line">                                            cloneUpdateQueue</span><br><span class="line">                                            processUpdateQueue <span class="comment">// 处理update queue，计算出最终state</span></span><br><span class="line">                                            reconcileChildren <span class="comment">// 处理children</span></span><br><span class="line">                                                mountChildFibers</span><br><span class="line">                                                    reconcileChildFibers</span><br><span class="line">                                                        placeSingleChild</span><br><span class="line">                                                            reconcileSingleElement</span><br><span class="line">                                    completeUnitOfWork <span class="comment">// !!! 将sibling设为workInProgress，没有则沿return找父节点的sibling，直到return为null</span></span><br><span class="line">                                        completeWork</span><br><span class="line">                            resetContextDependencies</span><br><span class="line">                            popDispatcher <span class="comment">// render结束，还原Dispatcher</span></span><br><span class="line">                        commitRoot</span><br><span class="line">                            commitRootImpl</span><br><span class="line">                                commitBeforeMutationEffects <span class="comment">// !!! 1阶段，Before Mutation，执行生命周期函数</span></span><br><span class="line">                                    prepareForCommit</span><br><span class="line">                                    commitBeforeMutationEffects_begin</span><br><span class="line">                                        commitBeforeMutationEffects_complete</span><br><span class="line">                                            commitBeforeMutationEffectsOnFiber <span class="comment">// 执行getSnapshotBeforeUpdate</span></span><br><span class="line">                                commitMutationEffects <span class="comment">// !!! 2阶段，根据fiber.flags更新DOM</span></span><br><span class="line">                                    commitMutationEffects_begin</span><br><span class="line">                                        commitMutationEffects_complete</span><br><span class="line">                                            commitDetachRef <span class="comment">// 解除ref</span></span><br><span class="line">                                            commitAttachRef <span class="comment">// 重新设置ref</span></span><br><span class="line">                                            commitPlacement</span><br><span class="line">                                                insertOrAppendPlacementNodeIntoContainer <span class="comment">// React DOM Api</span></span><br><span class="line">                                                insertOrAppendPlacementNode <span class="comment">// React DOM Api</span></span><br><span class="line">                                            commitWork</span><br><span class="line">                                                commitHookEffectListUnmount</span><br><span class="line">                                                commitContainer</span><br><span class="line">                                                    replaceContainerChildren <span class="comment">// React DOM Api</span></span><br><span class="line">                                commitLayoutEffects <span class="comment">// !!! 3阶段，执行layout</span></span><br><span class="line">                                    commitLayoutEffects_begin <span class="comment">// componentDidMount</span></span><br><span class="line">                                        safelyCallCommitHookLayoutEffectListMount</span><br><span class="line">                                            commitHookEffectListMount <span class="comment">// HookLayout</span></span><br><span class="line">                    ensureRootIsScheduled</span><br><span class="line">                entangleTransitions</span><br><span class="line">        getPublicRootInstance</span><br></pre></td></tr></table></figure>

<p>Update阶段（setState，其他类似）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span></span><br><span class="line">    classComponentUpdater.<span class="property">enqueueSetState</span></span><br><span class="line">        createUpdate</span><br><span class="line">        enqueueUpdate</span><br><span class="line">        scheduleUpdateOnFiber <span class="comment">// !!!核心函数</span></span><br><span class="line">            ensureRootIsScheduled</span><br><span class="line">                performConcurrentWorkOnRoot</span><br><span class="line">                    renderRootConcurrent</span><br><span class="line">                        pushDispatcher</span><br><span class="line">                        workLoopConcurrent <span class="comment">// !!!循环处理unitOfWork，正在处理的work称为workInProgress</span></span><br><span class="line">                            shouldYield <span class="comment">// !!!来自scheduler，为true时停止任务处理</span></span><br><span class="line">                            performUnitOfWork <span class="comment">// 和Mount类似，只不过只处理更新阶段对应的任务，以下省略</span></span><br><span class="line">                        popDispatcher</span><br><span class="line">                    finishConcurrentRender</span><br><span class="line">                        commitRoot <span class="comment">// 省略</span></span><br></pre></td></tr></table></figure>

<h2 id="Mount基本流程"><a href="#Mount基本流程" class="headerlink" title="Mount基本流程"></a>Mount基本流程</h2><ol>
<li>React.createElement()构建出React DOM；</li>
<li>ReactDOM.render()是React App初始化的起点，以下API如无特殊说明，默认属于<code>reconciler</code>库；<ol>
<li>构建两个互相引用的实例：fiberRoot是整个App的根节点，rootFiber是基于ReactDOM构建的Fiber Tree的根节点；</li>
<li>updateContainer正式开始reconcile过程，在此期间触发的更新以unbatched形式执行，主要执行两个函数：<ol>
<li>renderRootSync，进入render阶段，核心函数调用为：<ol>
<li>pushDispatcher，初始化一个ReactCurrentDispatcher，内含所有React Hook的实现；</li>
<li>workLoopSync，不同类型的FiberNode在render阶段对应不同的任务（例如类组件和函数组件，任务显然不同），WorkLoopSync通过一个循环<strong>同步地</strong>处理这些任务；</li>
<li>popDispatcher，还原ReactCurrentDispatcher；</li>
</ol>
</li>
<li>commitRoot，进入commit阶段，根据Diff结果更新浏览器DOM，触发对应Effect Hook或生命周期方法；</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="类组件Update基本流程"><a href="#类组件Update基本流程" class="headerlink" title="类组件Update基本流程"></a>类组件Update基本流程</h2><p>类组件有两种更新组件的方式：</p>
<ol>
<li>setState；</li>
<li>forceUpdate；</li>
</ol>
<p>这两个都是定义在React.Component.prototype上的方法，流程相似。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span> = <span class="keyword">function</span>(<span class="params">partialState, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forceUpdate</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueForceUpdate</span>(<span class="variable language_">this</span>, callback, <span class="string">&#x27;forceUpdate&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以setState为例的流程：</p>
<ol>
<li>创建update对象并添加进updateQueue；</li>
<li>调用scheduleUpdateOnFiber，开始处理更新：<ol>
<li>如果是batchedUpdates，则每次取消上个调度任务，再重新申请一个新的调度任务；</li>
<li>否则直接申请一个调度任务；</li>
</ol>
</li>
<li>轮到该任务执行时，进入workLoop</li>
</ol>
<p>注：被调度的任务就是<code>performConcurrentWorkOnRoot</code>函数；</p>
<h3 id="起点——classComponentUpdater"><a href="#起点——classComponentUpdater" class="headerlink" title="起点——classComponentUpdater"></a>起点——<code>classComponentUpdater</code></h3><p>实际调用的是<code>this.updater.enqueueSetState</code>，<code>this.updater</code>是在render阶段的<code>updateClassComponent</code> -&gt; <code>constructClassInstance</code> -&gt; <code>adoptClassInstance</code>函数中注入的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adoptClassInstance</span>(<span class="params">workInProgress: Fiber, instance: <span class="built_in">any</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// 注意这一行!!!instance就是ClassComponent的实例</span></span><br><span class="line">  instance.<span class="property">updater</span> = classComponentUpdater;</span><br><span class="line">  workInProgress.<span class="property">stateNode</span> = instance;</span><br><span class="line">  <span class="comment">// The instance needs access to the fiber so that it can schedule updates</span></span><br><span class="line">  <span class="title function_">setInstance</span>(instance, workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对照关系：</p>
<ol>
<li>setState：实际调用classComponentUpdater.enqueueSetState；</li>
<li>forceUpdate：实际调用classComponentUpdater.enqueueForceUpdate；</li>
</ol>
<p>其实这两个方法逻辑几乎一样，唯一不同点是setState需要携带上payload，也就是组件中调用setState时传入的partialState，而forceUpdate不需要携带payload，只是把update.tag置为ForceUpdate（一个二进制数）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">  isMounted,</span><br><span class="line">  <span class="title function_">enqueueSetState</span>(<span class="params">inst, payload, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = <span class="title function_">getInstance</span>(inst);</span><br><span class="line">    <span class="keyword">const</span> eventTime = <span class="title function_">requestEventTime</span>();</span><br><span class="line">    <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(eventTime, lane);</span><br><span class="line">    update.<span class="property">payload</span> = payload;</span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.<span class="property">callback</span> = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">enqueueUpdate</span>(fiber, update, lane);</span><br><span class="line">    <span class="keyword">const</span> root = <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">entangleTransitions</span>(root, fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">enqueueForceUpdate</span>(<span class="params">inst, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = <span class="title function_">getInstance</span>(inst);</span><br><span class="line">    <span class="keyword">const</span> eventTime = <span class="title function_">requestEventTime</span>();</span><br><span class="line">    <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(eventTime, lane);</span><br><span class="line">    update.<span class="property">tag</span> = <span class="title class_">ForceUpdate</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      update.<span class="property">callback</span> = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">enqueueUpdate</span>(fiber, update, lane);</span><br><span class="line">    <span class="keyword">const</span> root = <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">    <span class="keyword">if</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">entangleTransitions</span>(root, fiber, lane);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="批处理更新——UpdateQueue"><a href="#批处理更新——UpdateQueue" class="headerlink" title="批处理更新——UpdateQueue"></a>批处理更新——<code>UpdateQueue</code></h3><p>setState&#x2F;forceUpdate&#x2F;react hook等触发的更新会创建一个update对象，并添加到updateQueue，这是为了实现更新批处理而设计的，批处理生效期间，多次更新按顺序加到updateQueue中，期间每个更新会取消上一次更新的任务调度，并申请一次新的任务调度（scheduler提供任务调度能力），直到批处理结束，进入下一轮事件循环，被调度的任务得到执行机会，真正进入render阶段并通过<code>processUpdateQueue</code>一次性处理所有更新。</p>
<p>React合成事件默认开启更新批处理，其他场景必须手动调用<code>unstable_batchedUpdates</code>，例如异步的回调（setTimeout、Promise.then等）是无法批处理的，这里引申一个常见问题——setState是异步还是同步的？</p>
<p>注：这篇博客讲的非常好——<a target="_blank" rel="noopener" href="https://juejin.cn/post/6978304166154207239#heading-2">React 源码解读之 Automatic Batching</a></p>
<h4 id="setState是异步还是同步的？"><a href="#setState是异步还是同步的？" class="headerlink" title="setState是异步还是同步的？"></a><code>setState</code>是异步还是同步的？</h4><p>合成事件与生命周期函数中是异步的，异步函数回调与原生事件中是同步的。</p>
<p>注意，此处同步、异步并非指setState在JS引擎层面的同步或异步，而是指this.state的更新能否立刻体现出来：</p>
<ol>
<li>同步：setState后立刻可以通过this.state取到更新后的state；</li>
<li>异步：setState后不能立刻取到更新后的state；</li>
</ol>
<p>从源码层面解释：</p>
<ol>
<li>合成事件默认开启更新批处理，setState执行后并不会在本次事件循环中完成state更新，因此批处理结束前不能获取到最新state；</li>
<li>生命周期方法中的setState执行后，state的赋值不是立刻执行的，因此也无法得到最新state；</li>
</ol>
<p>异步函数、原生事件的回调中不会应用更新批处理，因此每个setState都会触发一次render、commit，因此可以setState后立刻获得最新state；</p>
<h3 id="开始调度——scheduleUpdateOnFiber"><a href="#开始调度——scheduleUpdateOnFiber" class="headerlink" title="开始调度——scheduleUpdateOnFiber"></a>开始调度——<code>scheduleUpdateOnFiber</code></h3><p>update会被赋予一个优先级，根据优先级选择对应的任务调度方式，SyncLane直接调用<code>performSyncWorkOnRoot</code>处理。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduleUpdateOnFiber</span></span><br><span class="line"><span class="keyword">if</span> (lane === <span class="title class_">SyncLane</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// Check if we&#x27;re inside unbatchedUpdates</span></span><br><span class="line">        (executionContext &amp; <span class="title class_">LegacyUnbatchedContext</span>) !== <span class="title class_">NoContext</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// Check if we&#x27;re not already rendering</span></span><br><span class="line">        (executionContext &amp; (<span class="title class_">RenderContext</span> | <span class="title class_">CommitContext</span>)) === <span class="title class_">NoContext</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// This is a legacy edge case. The initial mount of a ReactDOM.render-ed</span></span><br><span class="line">        <span class="comment">// root inside of batchedUpdates should be synchronous, but layout updates</span></span><br><span class="line">        <span class="comment">// should be deferred until the end of the batch.</span></span><br><span class="line">        <span class="title function_">performSyncWorkOnRoot</span>(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Schedule other updates after in case the callback is sync.</span></span><br><span class="line">    <span class="title function_">ensureRootIsScheduled</span>(root, eventTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他优先级通过<code>ensureRootIsScheduled</code>-&gt;<code>scheduleCallback</code>调度一个<code>performConcurrentWorkOnRoot</code>函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ensureRootIsScheduled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// !!!batchedUpdates情况下，取消上一次调度</span></span><br><span class="line"><span class="keyword">if</span> (existingCallbackNode != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Cancel the existing callback. We&#x27;ll schedule a new one below.</span></span><br><span class="line">    <span class="title function_">cancelCallback</span>(existingCallbackNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// !!!申请一个新的调度任务</span></span><br><span class="line"><span class="keyword">let</span> newCallbackNode;</span><br><span class="line"><span class="keyword">if</span> (newCallbackPriority === <span class="title class_">SyncLane</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> schedulerPriorityLevel;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="title function_">lanesToEventPriority</span>(nextLanes)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">DiscreteEventPriority</span>:</span><br><span class="line">        schedulerPriorityLevel = <span class="title class_">ImmediateSchedulerPriority</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">ContinuousEventPriority</span>:</span><br><span class="line">        schedulerPriorityLevel = <span class="title class_">UserBlockingSchedulerPriority</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">DefaultEventPriority</span>:</span><br><span class="line">        schedulerPriorityLevel = <span class="title class_">NormalSchedulerPriority</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">IdleEventPriority</span>:</span><br><span class="line">        schedulerPriorityLevel = <span class="title class_">IdleSchedulerPriority</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">        schedulerPriorityLevel = <span class="title class_">NormalSchedulerPriority</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// !!!看这里，调度一个performConcurrentWorkOnRoot</span></span><br><span class="line">    newCallbackNode = <span class="title function_">scheduleCallback</span>(</span><br><span class="line">        schedulerPriorityLevel,</span><br><span class="line">        performConcurrentWorkOnRoot.<span class="title function_">bind</span>(<span class="literal">null</span>, root),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>performConcurrentWorkOnRoot</code>得到执行机会时，会去执行<code>renderRootConcurrent</code>，若已经超时则直接以同步优先级执行<code>renderRootSync</code>.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performConcurrentWorkOnRoot</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> exitStatus =</span><br><span class="line">    <span class="title function_">shouldTimeSlice</span>(root, lanes) &amp;&amp;</span><br><span class="line">    (disableSchedulerTimeoutInWorkLoop || !didTimeout)</span><br><span class="line">      ? <span class="title function_">renderRootConcurrent</span>(root, lanes)</span><br><span class="line">      : <span class="title function_">renderRootSync</span>(root, lanes);</span><br></pre></td></tr></table></figure>

<h2 id="useState（非源码实现，待修改）"><a href="#useState（非源码实现，待修改）" class="headerlink" title="useState（非源码实现，待修改）"></a>useState（非源码实现，待修改）</h2><p>简单解释：</p>
<p>每个组件会维护一个<code>state对</code>数组，每次调用useState就向数组中添加一个<code>state对</code>，<code>state对</code>由state和setState函数组成，setState中维持对<code>state对</code>的引用，每个setState只能更新对应的state；</p>
<p>当组件挂载时，useState会创建<code>state对</code>，并将其加入<code>state对</code>数组，索引递增，指向下一个位置；</p>
<p>当组件更新时，索引置为0，再次调用useState只会移动<code>state对</code>数组的索引，并返回已经创建好的<code>state对</code>，因此，如果在if分支语句中使用useState，将可能导致useState返回错误的<code>state对</code>；</p>
<p>当调用<code>state对</code>的setState时，setState更新对应state的值，并调用React内部API，更新组件；</p>
<p>错误例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstRender = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (firstRender) &#123;</span><br><span class="line">        <span class="keyword">const</span> [name, setName] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;Neil&quot;</span>);</span><br><span class="line">        firstRender = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [gender， setGender] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;Male);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 首次挂载， 两次useState调用，state对 数组 like this</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    [&quot;</span><span class="title class_">Neil</span><span class="string">&quot;, setName],</span></span><br><span class="line"><span class="string">    [&quot;</span><span class="title class_">Male</span><span class="string">&quot;, setGender]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">// 组件更新，state对数组不变，但由于只有一次useState调用，索引初始为0，React.useState(&quot;</span><span class="title class_">Male</span><span class="string">&quot;)得到的state对是[&quot;</span><span class="title class_">Neil</span><span class="string">&quot;, setName]</span></span><br><span class="line"><span class="string">// 这就会导致setGender实际上修改的是name的值</span></span><br></pre></td></tr></table></figure>

<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul>
<li>类组件state的更新发生在mountClassInstance，被赋值为workInProgress.memoizedState；</li>
</ul>

                </div>
            
    </section>
</article>




    <a id="pagenext" href="/2023/05/28/interview/interview-reactrouter/" class="article-next" title="前端进阶（react-router）"><i class="icon-arrow-right"></i></a>


    <a id="pageprev" href="/2023/05/31/react/react_fiber_node/" class="article-prev" title="React v17.0.2源码（Fiber Node）"><i class="icon-arrow-left"></i></a>





            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>

</body>
</html>
