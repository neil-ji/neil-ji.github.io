<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>CSS基础 | Neil&#39;s Blog</title>
    <meta name="author" content="Neil Ji" />
    <meta name="keywords" content="react,js,javascript,react17.0.2,ts,typescript,redux,mobx" />
    <meta name="description" content="盒模型盒模型分为四部分：margin boxborder boxpadding boxcontent box标准盒模型（content-box）：block 盒子可设置宽高（默认占满父容器宽度），padding&amp;#x2F;margin&amp;#x2F;border 会把其他元素推开，width&amp;#x2F;height 是指 content box 的宽高，整个 block 盒子的宽高应加上 padding box 和 border box，默认换行；inline 盒子不可设置宽高（由内容决定），pad" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    <link rel="alternate" href="/atom.xml" title="Neil&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    
<link rel="stylesheet" href="/css/style.css">


    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
<meta name="generator" content="Hexo 6.3.0"></head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">Neil&#39;s Blog</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <!-- <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://neil-ji.github.io"></form> -->

        
            
                
                    

                        
                            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#px-x2F-em-x2F-rem-x2F-vw-x2F-vh"><span class="toc-number">2.</span> <span class="toc-text">px&#x2F;em&#x2F;rem&#x2F;vw&#x2F;vh</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pixel-%E4%B8%8E-css-%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D-px"><span class="toc-number">3.</span> <span class="toc-text">pixel 与 css 长度单位 px</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%8F%E7%B4%A0%E3%80%81%E5%88%86%E8%BE%A8%E7%8E%87%E3%80%81ppi-%E5%8F%8A%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.</span> <span class="toc-text">像素、分辨率、ppi 及屏幕尺寸的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E5%86%99%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%80%BB%E8%BE%91%E6%96%B9%E5%90%91%EF%BC%88writing-mode-amp-logic-x2F-physical-properties%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">书写模式与逻辑方向（writing-mode &amp; logic&#x2F;physical properties）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9ABFC-amp-IFC"><span class="toc-number">6.</span> <span class="toc-text">格式化上下文：BFC &amp; IFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA-BFC"><span class="toc-number">7.</span> <span class="toc-text">如何创建 BFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFC-%E7%89%B9%E7%82%B9%E5%8F%8A%E5%8F%AF%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">BFC 特点及可解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IFC-%E7%89%B9%E7%82%B9"><span class="toc-number">9.</span> <span class="toc-text">IFC 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">常见布局方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%81%9A%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">隐藏元素的几种做法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%B6%85%E9%95%BF%E6%88%AA%E6%96%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.</span> <span class="toc-text">文本超长截断的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E4%B9%8B-transform-vs-margin"><span class="toc-number">13.</span> <span class="toc-text">元素居中之 transform vs margin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#position%E7%9B%B8%E5%85%B3"><span class="toc-number">14.</span> <span class="toc-text">position相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#position-sticky%E7%9B%B8%E5%85%B3"><span class="toc-number">15.</span> <span class="toc-text">position:sticky相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sticky-polyfill-%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%80%E5%8C%96%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">sticky polyfill 实现（简化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#z-index"><span class="toc-number">17.</span> <span class="toc-text">z-index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="toc-number">18.</span> <span class="toc-text">CSS 实现多边形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS3-%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7"><span class="toc-number">19.</span> <span class="toc-text">CSS3 新增特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flex-1%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">20.</span> <span class="toc-text">flex: 1的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">21.</span> <span class="toc-text">选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">21.1.</span> <span class="toc-text">CSS 优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">21.2.</span> <span class="toc-text">属性选择器详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">22.</span> <span class="toc-text">响应式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">23.</span> <span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transition"><span class="toc-number">23.1.</span> <span class="toc-text">Transition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animation"><span class="toc-number">23.2.</span> <span class="toc-text">Animation</span></a></li></ol></li></ol>
                                
    </div>
</aside>
</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            CSS基础
        </h1>
        
        <div class="article-meta clearfix">
            
            <a class="article-date" href="/archives/2023/03/01">
    
    <i class="icon-calendar vm"></i>
    
    
        <span class="vm">Created at</span>
    
    <time class="vm" datetime="2023-03-01T12:10:00.000Z" itemprop="datePublished">2023-03-01</time>
</a>

            <div class="article-updated">
    
    <i class="icon-calendar vm"></i>
    
    
        <span class="vm">Modified at</span>
    
    <time class="vm" datetime="2024-03-14T09:27:27.920Z" itemprop="datePublished">2024-03-14</time>
</div>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/css/" rel="tag">css</a>, <a class="article-tag-link" href="/tags/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/" rel="tag">前端进阶</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        <div>
            
            
                
            
            
                <h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型分为四部分：</p>
<ul>
<li>margin box</li>
<li>border box</li>
<li>padding box</li>
<li>content box</li>
</ul>
<p>标准盒模型（content-box）：</p>
<ul>
<li>block 盒子可设置宽高（默认占满父容器宽度），padding&#x2F;margin&#x2F;border 会把其他元素推开，width&#x2F;height 是指 content box 的宽高，整个 block 盒子的宽高应加上 padding box 和 border box，默认换行；</li>
<li>inline 盒子不可设置宽高（由内容决定），padding&#x2F;margin&#x2F;border 可以生效，但只有内联方向的值会把其他 inline 盒子推开，且默认不换行；现代浏览器默认为标准盒模型。</li>
</ul>
<p>替代盒模型（border-box）：宽高计算方式改变，width&#x2F;height 是指 border box 的宽高，同时就是盒子的实际宽高。</p>
<p>盒模型转换：可通过 box-sizing 设置元素为标准（content-box）或替代（border-box）盒模型。</p>
<p>Others：</p>
<ul>
<li>inline-block 外部显示为 inline 盒子，内部显示为 block 盒子；</li>
<li>相邻盒子块方向上的 margin 会折叠（只保留最大的 margin）；</li>
<li>将盒模型设置为 border-box 方便计算盒子宽高；</li>
</ul>
<h2 id="px-x2F-em-x2F-rem-x2F-vw-x2F-vh"><a href="#px-x2F-em-x2F-rem-x2F-vw-x2F-vh" class="headerlink" title="px&#x2F;em&#x2F;rem&#x2F;vw&#x2F;vh"></a>px&#x2F;em&#x2F;rem&#x2F;vw&#x2F;vh</h2><ul>
<li>px：CSS 像素单位；</li>
<li>em：用于 font-size 时，指相对于父元素 font-size 的倍数；用于其他属性时，指相对于自身 font-size 的倍数；</li>
<li>rem：指相对于根元素（html）font-size 的倍数；</li>
<li>vw：viewport 宽的 1%；</li>
<li>vh：viewport 长的 1%；</li>
</ul>
<p>注：对同一设备而言，px 是绝对长度，em&#x2F;rem&#x2F;vw&#x2F;vh 是相对长度；</p>
<h2 id="pixel-与-css-长度单位-px"><a href="#pixel-与-css-长度单位-px" class="headerlink" title="pixel 与 css 长度单位 px"></a>pixel 与 css 长度单位 px</h2><ul>
<li>pixel：针对设备而言，由硬件决定，表示屏幕上一个最小显示单元；</li>
<li>css px：针对 css 而言，由浏览器决定，一般定义为 1&#x2F;96 inch 左右，也就是说 96px 约等于物理意义的 1 英寸；</li>
</ul>
<h2 id="像素、分辨率、ppi-及屏幕尺寸的关系"><a href="#像素、分辨率、ppi-及屏幕尺寸的关系" class="headerlink" title="像素、分辨率、ppi 及屏幕尺寸的关系"></a>像素、分辨率、ppi 及屏幕尺寸的关系</h2><ul>
<li>px：像素是虚拟单位，表示最小的独立色块；</li>
<li>分辨率：设备硬件决定分辨率，一般表示为：横向像素数量 * 竖向像素数量，即屏幕上的总像素数量；</li>
<li>ppi：pixel per inch，也称为像素密度，显然本身是一个单位；</li>
<li>屏幕尺寸：屏幕对角线的物理长度，单位 inch；</li>
</ul>
<h2 id="书写模式与逻辑方向（writing-mode-amp-logic-x2F-physical-properties）"><a href="#书写模式与逻辑方向（writing-mode-amp-logic-x2F-physical-properties）" class="headerlink" title="书写模式与逻辑方向（writing-mode &amp; logic&#x2F;physical properties）"></a>书写模式与逻辑方向（writing-mode &amp; logic&#x2F;physical properties）</h2><p>writing-mode：horizontal-tb&#x2F;vertical-rl&#x2F;vertical-lr 用于控制书写方向，同时也会决定块和行的流动方向（进而影响盒子的排列方式）。</p>
<ul>
<li>当书写方向为 horizontal-tb （top to bottom）时，从上到下为块流动方向，从左到右为行流动方向；</li>
<li>当书写方向为 vertical-rl （right to left）时，从右到左为块流动方向，从上到下为行流动方向；</li>
<li>当书写方向为 vertical-lr （left to right）时，从左到右为块流动方向，从上到下为行流动方向；</li>
</ul>
<p>从逻辑角度控制全局，而非物理&#x2F;维度等角度，从而保证不同的 writing-mode 下表现也仍然一致，以下列举部分属性：</p>
<ul>
<li>block-size 等同于 horizontal-tb 时的 height，vertical 时的 width（max&#x2F;min-block-size 一样）；</li>
<li>inline-size 等同于 horizontal-tb 时的 width，vertical 时的 height（max&#x2F;min-block-size 一样）；</li>
</ul>
<p>大致规则就是假设 writing-mode：horizontal-tb，然后 block&#x2F;inline 指示轴线，start&#x2F;end 指示起始位置，根据物理属性可以推导出其逻辑属性，例如 margin-left，对应 margin-inline-start.</p>
<h2 id="格式化上下文：BFC-amp-IFC"><a href="#格式化上下文：BFC-amp-IFC" class="headerlink" title="格式化上下文：BFC &amp; IFC"></a>格式化上下文：BFC &amp; IFC</h2><p>Formatting Context，一种虚拟概念，表示一个具有特定布局规则的区域</p>
<ul>
<li>BFC 是块级格式化上下文；</li>
<li>IFC 是内联格式化上下文；</li>
</ul>
<h2 id="如何创建-BFC"><a href="#如何创建-BFC" class="headerlink" title="如何创建 BFC"></a>如何创建 BFC</h2><p>对于 block 元素，满足以下任意一点即可创建 BFC：</p>
<ol>
<li>根元素<html></li>
<li>position: absolute&#x2F;fixed&#x2F;sticky</li>
<li>float item</li>
<li>display 为<ol>
<li>inline-block</li>
<li>table-cell（表格单元格）</li>
<li>table-captain（表格标题）</li>
<li>flow-root（HTML 根元素）</li>
</ol>
</li>
<li>flex-item, grid-item</li>
<li>多列布局元素</li>
<li>overflow: 非 visible</li>
</ol>
<h2 id="BFC-特点及可解决的问题"><a href="#BFC-特点及可解决的问题" class="headerlink" title="BFC 特点及可解决的问题"></a>BFC 特点及可解决的问题</h2><p>特点</p>
<ul>
<li>BFC 内部所有元素的 block 方向上的 margin 将会折叠</li>
<li>BFC 内部元素的布局不影响外部元素</li>
</ul>
<p>通过父元素创建 BFC 可以解决：</p>
<ul>
<li>父子元素外边距折叠；</li>
<li>隔离 float 元素的影响；</li>
<li>父元素高度坍塌；</li>
</ul>
<p>注 1：一般通用的创建 BFC 方法为 overflow：hidden&#x2F;scroll&#x2F;auto；</p>
<p>注 2：容器高度坍塌是指内部元素由于脱离正常文档流，导致容器高度计算时不会计算内部元素高度，进而使得高度缩小；</p>
<h2 id="IFC-特点"><a href="#IFC-特点" class="headerlink" title="IFC 特点"></a>IFC 特点</h2><p>IFC 由内联盒子（inline box）创建，IFC 内会划分出行框（line box），然后将所有内容放入行框，假如出现换行，则新创建一个行框。</p>
<p>特点：</p>
<ul>
<li>inline 元素水平排列；</li>
<li>上下方向的 margin、padding、height 不生效；</li>
<li>用 line-height 代替 height（其实，我认为该属性的命名就是指：height of line box）；</li>
</ul>
<h2 id="常见布局方式"><a href="#常见布局方式" class="headerlink" title="常见布局方式"></a>常见布局方式</h2><ul>
<li>正常文档流布局（兼容所有浏览器）</li>
<li>基于 position 的布局（IE 不兼容 position：sticky）</li>
<li>基于 float 的 Multicol 布局（几乎兼容所有浏览器）</li>
<li>网格布局（IE 10 使用-ms-前缀实现了旧版规范）</li>
<li>弹性布局（IE 8 使用-ms-flexbox 前缀实现了旧版规范；IE 11 中 inline block 元素会被错误定位）</li>
<li>Multicol 布局（IE 10 +）</li>
</ul>
<h2 id="隐藏元素的几种做法"><a href="#隐藏元素的几种做法" class="headerlink" title="隐藏元素的几种做法"></a>隐藏元素的几种做法</h2><ul>
<li><code>opacity: 0</code>，DOM 没有移除，布局没有改变，可以点击，仍然需要计算 CSS；</li>
<li><code>visibility: hidden</code>，DOM 没有移除，布局没有改变，可以点击，不需要计算 CSS；</li>
<li><code>display: none</code>，完全移除 DOM，布局改变，不可点击；</li>
</ul>
<h2 id="文本超长截断的实现"><a href="#文本超长截断的实现" class="headerlink" title="文本超长截断的实现"></a>文本超长截断的实现</h2><p>单行文本</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;</span><br></pre></td></tr></table></figure>

<p>多行文本（兼容性不佳）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">-webkit-line-clamp: <span class="number">3</span>; //行数</span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br></pre></td></tr></table></figure>

<h2 id="元素居中之-transform-vs-margin"><a href="#元素居中之-transform-vs-margin" class="headerlink" title="元素居中之 transform vs margin"></a>元素居中之 transform vs margin</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.transform-center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.margin-center</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.transform-center</code>元素脱离文档流，在新图层渲染；</li>
<li><code>.margin-center</code>元素不脱离文档流；</li>
</ul>
<p>注：如果页面会频繁改变边距，那么<code>.transform-center</code>是性能更优的选择，而且还可以实现一些边距改变时的动画效果。</p>
<h2 id="position相关"><a href="#position相关" class="headerlink" title="position相关"></a><code>position</code>相关</h2><ul>
<li>static（default）：静态定位，根据文档中的源顺序决定排列顺序；</li>
<li>relative：相对定位，相对于文档中自身位置进行定位；</li>
<li>absolute：绝对定位，相对于最近的非 static 祖先元素定位，将脱离正常文档流；</li>
<li>fixed：固定定位，相对于 Viewport 定位，将脱离正常文档流；</li>
<li>sticky：粘性定位，使用 top&#x2F;right&#x2F;bottom&#x2F;left 设定阈值，初始时等同于 static 定位，通过滚动使其位置达到阈值，此时等同于 fixed 定位。</li>
</ul>
<h2 id="position-sticky相关"><a href="#position-sticky相关" class="headerlink" title="position:sticky相关"></a><code>position:sticky</code>相关</h2><p>效果：sticky 定位的元素，相对于<strong>有滚动条</strong>的<strong>最近块级祖先</strong>元素，其偏移量：</p>
<ul>
<li>未超过预设值（top&#x2F;right&#x2F;bottom&#x2F;left），则随页面滚动；</li>
<li>超过预设值，则不随页面滚动，而是固定在屏幕上；</li>
</ul>
<p>细节：</p>
<ul>
<li>偏移量是相对于<strong>有滚动条</strong>的<strong>最近块级祖先</strong>元素计算的，如果没有，则相对于 viewport 计算；</li>
<li>会创建 stacking context；</li>
<li>其<strong>最近块级祖先</strong>的 overflow 不能为 hidden、scroll、auto、overlay；</li>
<li>不会脱离正常文档流；</li>
</ul>
<h2 id="sticky-polyfill-实现（简化）"><a href="#sticky-polyfill-实现（简化）" class="headerlink" title="sticky polyfill 实现（简化）"></a>sticky polyfill 实现（简化）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sticky-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;item&quot;</span> <span class="attr">class</span>=<span class="string">&quot;sticky-item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sticky-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sticky-item</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sticky-item-fixed</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> item = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;item&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elOffset = container.<span class="property">offsetTop</span>;</span><br><span class="line">  <span class="keyword">const</span> pageOffset = <span class="variable language_">window</span>.<span class="property">pageYOffset</span>;</span><br><span class="line"></span><br><span class="line">  item.<span class="property">className</span> = pageOffset &gt; elOffset ? <span class="string">&quot;sticky-item&quot;</span> : <span class="string">&quot;sticky-item-fixed&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>包一层 relative 定位的 div，避免内部元素脱离文档流后（<code>position: fixed</code>）offsetTop 丢失；</li>
<li><code>pageXOffset,pageYOffset</code>是<strong>文档左上角</strong>相对于<strong>viewport 左上角</strong>的横、纵向偏移量，单位是 px，兼容性好于<code>scrollX,scrollY</code>；</li>
<li>只模拟效果，未考虑其他复杂情况，例如 sticky 元素偏移量计算的参考元素（祖先元素）脱离 viewport 时如何显示，等等；</li>
</ul>
<h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>决定元素堆叠顺序，值越大，堆叠越靠前；非 static 元素 z-index 默认为 auto，实际值为 0，但 auto 不会创建新的本地堆叠上下文，指定一个 number 会创建一个新的本地堆叠上下文，上下文中的子元素的 z-index 将不会对外部元素生效。</p>
<h2 id="CSS-实现多边形"><a href="#CSS-实现多边形" class="headerlink" title="CSS 实现多边形"></a>CSS 实现多边形</h2><p>原理：借助盒模型理解，border 的相邻两边，其邻接处是一条斜线；</p>
<ul>
<li>height&#x2F;width 设为 0，隐去 border 的某些边（border-color: transparent），可得三角形；</li>
<li>height&#x2F;width 不为 0，隐去 border 的某些边，可得梯形；</li>
<li>以上任意组合，可得多边形；</li>
</ul>
<h2 id="CSS3-新增特性"><a href="#CSS3-新增特性" class="headerlink" title="CSS3 新增特性"></a>CSS3 新增特性</h2><ul>
<li>选择器</li>
<li>盒子模型属性：border-radius、box-shadow、border-image</li>
<li>背景：background-size、background-origin、background-clip</li>
<li>文本效果：text-shadow、word-wrap</li>
<li>颜色：新增 RGBA，HSLA 模式</li>
<li>渐变：线性渐变、径向渐变</li>
<li>字体：@font-face</li>
<li>2D&#x2F;3D 转换：transform、transform-origin</li>
<li>过渡与动画：transition、@keyframes、animation</li>
<li>多列布局</li>
<li>媒体查询</li>
</ul>
<h2 id="flex-1的含义"><a href="#flex-1的含义" class="headerlink" title="flex: 1的含义"></a><code>flex: 1</code>的含义</h2><p><code>flex</code>是 flex-grow、flex-shrink 和 flex-basis 的简写属性，共有三种语法形式，这里<code>flex:1</code>是单值语法，含义是指定<code>flex-grow: 1</code>，shrink 和 basis 分别默认为 1 和 0；</p>
<p>进一步的说，<code>flex-grow: 1</code>是指弹性容器如果出现剩余空间，此时按照 flex-grow 设置的比例去拉伸 flex item 以填充剩余空间；</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul>
<li>Basic Selector<ul>
<li>Universal（*）</li>
<li>Type（div）</li>
<li>Class（.class）</li>
<li>ID（#id）</li>
<li>Attribute（[attr] [attr&#x3D;value] [attr~&#x3D;value] [attr|&#x3D;value] [attr^&#x3D;value]）</li>
</ul>
</li>
<li>Group Selector（any, any）</li>
<li>Combinators<ul>
<li>Descendant（A B）</li>
<li>Child（A &gt; B）</li>
<li>General sibling（A ~ B）</li>
<li>Adjacent sibling （A + B）</li>
<li>Column ( A || B )，目前所有浏览器都不支持</li>
</ul>
</li>
<li>Pseudo<ul>
<li>Class （:visited）</li>
<li>Element（::nth-child）</li>
</ul>
</li>
</ul>
<h3 id="CSS-优先级"><a href="#CSS-优先级" class="headerlink" title="CSS 优先级"></a>CSS 优先级</h3><p>关系选择器本身没有优先级，但由关系选择器组合而成的选择器的优先级，由基础选择器的优先级的权重计算而成，基础选择器优先级权重如下：</p>
<ul>
<li>最高级： 内联样式</li>
<li>次高级： id 选择器</li>
<li>中级： 类，属性，伪类选择器</li>
<li>低级： 元素，伪元素选择器</li>
</ul>
<p>马克思主义原理——量变质变，反着记：<strong>量变不会导致质变</strong>。也就是说，同级权重即便累加（量变），也不会超越更高级的权重（质变）。</p>
<p>!important 标识的 CSS 属性优先级超越以上任何权重。</p>
<h3 id="属性选择器详解"><a href="#属性选择器详解" class="headerlink" title="属性选择器详解"></a>属性选择器详解</h3><ul>
<li>[attr] 精确匹配属性 attr</li>
<li>[attr&#x3D;”value”] 精确匹配属性 attr 和值 value</li>
<li>[attr|&#x3D;”value”] 精确匹配属性 attr 和以 value 开头的值，value 可后接连字符”-“</li>
<li>[attr~&#x3D;”value”] 精确匹配属性 attr 和以空格分隔含有 value 子串的值</li>
<li>[attr^&#x3D;”value”] 属性同上，以 value 开头的值</li>
<li>[attr$&#x3D;”value”] 属性同上，以 value 结尾的值</li>
<li>[attr*&#x3D;”value”] 属性同上，模糊匹配含 value 的值</li>
<li>[attr&#x3D;”ValuE”i] 大小写不敏感的值匹配</li>
</ul>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>响应式布局技术：现代布局有 flex&#x2F;grid&#x2F;multi-column</p>
<p>媒体查询：通过<code>@media</code> 指令开启，语法包含两部分：媒体类型（media-type）和媒体条件（media-condition）。可通过与（and）或（,）非（not）混合媒体类型和条件。</p>
<p>常用媒体类型如下：</p>
<ul>
<li>all：所有媒体；</li>
<li>print：打印机；</li>
<li>screen：屏幕设备；</li>
<li>speech：阅读器；</li>
</ul>
<p>常用媒体特征如下：</p>
<ul>
<li>width&#x2F;height：明确指定的媒体设备的 width&#x2F;height；</li>
<li>min-width&#x2F;min-height：范围 width&#x2F;height，媒体设备宽&#x2F;高大于该值时，表达式才为真；</li>
<li>max-width&#x2F;max-height：范围 width&#x2F;height，媒体设备宽&#x2F;高小于该值时，表达式才为真；</li>
<li>orientation：portrait&#x2F;landscape，portrait 意为处于 viewport 纵向，即宽小于高，landscape 相反；</li>
<li>hover：none&#x2F;hover，媒体是否支持悬浮操作（可用于判断是否是触摸屏设备）；</li>
<li>pointer：none&#x2F;fine&#x2F;coarse，媒体支持的指针设备精度如何，fine 为高精度指针（如鼠标），coarse 为低精度指针（如触摸屏）；</li>
</ul>
<p>排版：使用 em&#x2F;rem&#x2F;vw&#x2F;vh 等相对单位。</p>
<p>元标签：使用<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</code>覆盖移动端浏览器的 viewport 的某些属性，例如 width&#x2F;height&#x2F;initial-scale 等，来使移动端浏览器的 viewport 属性符合我们的预期。</p>
<p>响应式图片实现技巧：为不同设备的用户提供不同的图片，借助<code>srcset</code>&#x2F;<code>sizes</code>&#x2F;<code>&lt;picture&gt;</code> 实现图片尺寸&#x2F;分辨率的自适应，IE 不支持<code>srcset</code>&#x2F;<code>picture</code>，实现方式有如下几种。</p>
<ol>
<li><code>srcset + sizes</code>：srcset 设置图片集，url + 像素宽（单位 w），之间以逗号分隔，每个 url 对应一张图片，像素宽就是该图片的像素宽度，sizes 设置多个媒体条件，格式为 (media condition) + 图片槽宽度，以逗号分隔，当媒体条件为真时图像将要填充指定宽度的图片槽，特别的是最后一条应当省略媒体条件，以作为所有条件都不匹配时的默认值。浏览器根据 sizes 获取图片槽宽度，选择 srcset 中最接近的一张图片加载。</li>
<li><code>srcset</code>：设置图片集，url + css 像素&#x2F;device 像素 + x，例如(<a target="_blank" rel="noopener" href="https://test.com/1.jpg">https://test.com/1.jpg</a> 1.5x)，设备大小相同，但是发光点数量可能不同，所以可能出现两个发光点来渲染出一个 css 像素点的情况，这时可以用语法 2x 表示，此时将会选择对应的图片加载。特别的是 1x 可以省略。</li>
<li><code>&lt;picture&gt;</code>：设置其子元素<code>&lt;source&gt;</code>，source 的 media 属性可以设置一个媒体条件，srcset 属性可以设置为 url + 像素宽，当媒体条件匹配时，该图片才会加载，最后一个子元素应当是一个<code>&lt;img&gt;</code>标签作为默认图片。</li>
</ol>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>添加厂商前缀（如-ms，-webkit 等）可以增强其兼容性，但一般通过类库统一处理</p>
<ul>
<li>transition-property：定义需要动画过渡的属性；</li>
<li>transition-duration：time 定义动画的演出时间；</li>
<li>transition-timing-function：定义缓动函数（控制动画播放节奏）；</li>
<li>transition-delay：time 定义动画的延迟时间；</li>
<li>transition：上述属性的简写，第一个时间被解析为 duration，第二个被解析为 delay，其他属性先后顺序不重要；</li>
</ul>
<h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>规则<code>@keyframes</code>用于定义动画关键帧列表，用百分比标识时间点，0% 和 100% 别名分别为 from 和 to，语法格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> slidein &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>animation 相关属性如下：</p>
<ul>
<li>animation-name：@keyframes name 用于指定动画的关键帧列表，设置为 none 可取消动画；</li>
<li>animation-duration：time 用于指定动画的一个演出周期的时长；</li>
<li>animation-delay：time 用于指定动画延迟时间；</li>
<li>animation-timing-function：定义缓动函数（控制动画播放节奏）；</li>
<li>animation-iteration-count：number 用于定义动画循环次数，指定为 0 则动画将立刻结束，指定为 infinite 则为无限循环，指定为小数则最后一次动画将以小数点后的百分比作为最后一个关键帧；</li>
<li>animation-direction：默认为 normal 指动画方向不变；reverse 指动画播放从 to 到 from 的关键帧；alternate 指动画正向播放后再反向播放；alternate-reverse 指动画反向播放后再正向播放；</li>
<li>animation-fill-mode：默认为 none 指动画未执行时，不会把任何样式应用于目标；forwards 指动画执行结束后最后一个关键帧的样式将持续应用于目标上，执行前不存在影响；backwards 指执行之前第一个关键帧的样式将持续应用于目标上，结束后消失；both 是 forwads 和 backwards 的叠加，目标将在动画开始前应用第一个关键帧，并在动画结束后应用最后一个关键帧；该属性受 animation-direction &amp; animation-iteration-count 影响；</li>
<li>animation-play-state：running 指动画正在执行，paused 指动画已被暂停，通过该属性查询&#x2F;设置动画执行的状态；</li>
<li>animation：上述属性的简写，时间按相对顺序解析，第一个解析为 duration，第二个为 delay，其他属性顺序不重要；</li>
</ul>

                </div>
            
    </section>
</article>




    <a id="pagenext" href="/2023/03/01/css/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/" class="article-next" title="常见Web布局"><i class="icon-arrow-right"></i></a>


    <a id="pageprev" href="/2023/03/09/browser/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" class="article-prev" title="Execution Context"><i class="icon-arrow-left"></i></a>





            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>

</body>
</html>
