<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />

    

    

    <title>Neil&#39;s Blog</title>
    <meta name="author" content="Neil Ji" />
    <meta name="keywords" content="" />
    <meta name="description" content="" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

    
    <link rel="alternate" href="/atom.xml" title="Neil&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    
<link rel="stylesheet" href="/css/style.css">


    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
<meta name="generator" content="Hexo 6.3.0"></head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">Neil&#39;s Blog</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item active" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <!-- <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://neil-ji.github.io"></form> -->

        
            

                        
                                    <div class="author-meta">
                                        
                                            <div class="author-avatar">
                                                <a href="/">
                                                    <img src="/images/avatar.png"
                                                        title="Neil">
                                                </a>
                                            </div>
                                            
                                                <div class="author-name">
                                                    Neil
                                                </div>
                                                <div class="author-work">Web Developer</div>
                                                <div class="author-location">
                                                    <i class="icon-location vm"></i>
                                                    <span class="vm">
                                                        China
                                                    </span>
                                                </div>
                                                
                                                    <div class="author-thread-wrap">
                                                        <div class="author-threads clearfix">
                                                            
                                                                <a class="thread-item" href="https://github.com/neil-ji"
                                                                    target="_blank" rel="noopener">
                                                                    <!-- Generated by IcoMoon.io -->
<svg viewBox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"></path>
</svg>

                                                                </a>
                                                                
                                                        </div>
                                                    </div>
                                                    <div class="author-description">
                                                        做一个Azad，自由的人，像柏树一样——希克·萨迪《花园》
                                                    </div>
                                                    
                                    </div>
                                    
    </div>
</aside>
</header>

        <div id="content" class="content">
            <div id="wrapper" class="wrapper" style="max-width: 800px">
                
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/06/11/js/js_executioncontext/">Execution Context</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-06-11T08:31:09.487Z" itemprop="datePublished">2023-06-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/" rel="tag">浏览器内核</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JS引擎只确保Execution Context描述的机制，但不确保采用什么手段去实现。</p>
<p>首先，Execution Context是ECMAScript语言规范中的抽象概念，它旨在建立一种易于描述和实现的ECMAScript运行机制，JavaScript是ECMAScript的一种实现，而JavaScript引擎，例如V8、SpiderMonkey、Carakan等，在实现JavaScript运行环境时，并不一定会采用固定方式实现Execution Context，更不会强调哪些类、方法或函数是与Execution Context有关的，也许其实现有关的代码到处都是。</p>
<p>但了解Execution Context仍然是有意义的，概念可以帮助我们理解现象。</p>
        
        <p class="article-more-link">
            <a href="/2023/06/11/js/js_executioncontext/#more">
                <span class="vm">阅读全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/06/11/css/css_20230301/">常见Web布局</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-06-11T08:31:09.480Z" itemprop="datePublished">2023-06-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/css/" rel="tag">css</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="正常文档流布局（兼容所有浏览器）"><a href="#正常文档流布局（兼容所有浏览器）" class="headerlink" title="正常文档流布局（兼容所有浏览器）"></a>正常文档流布局（兼容所有浏览器）</h2><p>按照元素在文档中的出现顺序与书写方向（write-mode），搭配盒模型进行布局。</p>
<h2 id="基于position-的布局（IE-不兼容position：sticky）"><a href="#基于position-的布局（IE-不兼容position：sticky）" class="headerlink" title="基于position 的布局（IE 不兼容position：sticky）"></a>基于position 的布局（IE 不兼容position：sticky）</h2><p>通过修改元素的position 来实现一些特殊布局效果。</p>
        
        <p class="article-more-link">
            <a href="/2023/06/11/css/css_20230301/#more">
                <span class="vm">阅读全文</span>
                <i class="icon-arrow-double-right vm"></i>    
            </a>
        </p>
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/06/11/algorithm/algorithm_leetcode32/">LeetCode Hard 32. 最长有效括号</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-06-11T08:31:09.478Z" itemprop="datePublished">2023-06-11</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/leetcode/" rel="tag">leetcode</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>注释比较长，耐心看，<strong>重点一</strong>是看懂dp[i]表示的是什么，那就是从j到i的合法子串长度，0 &lt;&#x3D; j &lt;&#x3D; i，<strong>重点二</strong>是j可由等式dp[i] &#x3D; i - j + 1变形求得，<strong>重点三</strong>是对贪心法的理解，只取局部最优，按这个思路考虑，每次迭代尾字符要么是<code>(</code>要么是<code>)</code>，则：</p>
<ol>
<li><code>...(</code>一定不合法</li>
<li><code>...)</code>要分情况讨论：<ol>
<li><code>...()</code>一定合法</li>
<li><code>...))</code>可能合法，继续分情况讨论：<ol>
<li><code>...((valid))</code>，valid表示合法子串，可以为空字符串，一定合法；</li>
<li><code>...((invalid))</code>，invalid要么是<code>(</code>，要么是<code>)</code><ol>
<li>例如<code>...((())</code>，一定是先由1分支处理，取得局部最优解，减小问题规模，再由2.2.1处理</li>
<li>再例如<code>...(()))</code>一定是先由2.2.1处理变为<code>...valid)</code>，取得局部最优解，减小问题规模，继续由2处理；</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>可见2.2.2的invalid无论是什么，都可以通过该策略取得局部最优，减小问题规模后重新应用该策略，这是贪心法的特征；</p>
<p>另外上面不是贪心证明，只是从代码逆推策略，找不出反例，所以姑且认为对，希望有大佬给个证明；</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestValidParentheses = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = [<span class="number">0</span>]; <span class="comment">// dp[x]表示从y到x的合法子串长度，0 &lt;= y &lt;= x，此处有一个相等关系，dp[x] = x - y + 1；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&quot;(&quot;</span>) &#123; <span class="comment">// 以 ( 结尾必不合法</span></span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i - <span class="number">1</span>] === <span class="string">&quot;(&quot;</span>) &#123; <span class="comment">// 以 ) 结尾，且前一个字符为 (，合法</span></span><br><span class="line">            <span class="comment">// 结果为dp[i - 2] + 2，i - 2可能越下界，越界用0缺省</span></span><br><span class="line">            dp[i] = (dp[i - <span class="number">2</span>] || <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i - <span class="number">1</span>] === <span class="string">&quot;)&quot;</span> &amp;&amp; s[i - <span class="number">1</span> - dp[i - <span class="number">1</span>]] === <span class="string">&quot;(&quot;</span>) &#123; <span class="comment">// 以 ) 结尾，且前一个字符为 )，且再往前有子串((，合法</span></span><br><span class="line">            <span class="comment">// 注意此处，x = i - 1，dp[x]已知</span></span><br><span class="line">            <span class="comment">// 求y到x的合法字串的首字符下标，就也是求y</span></span><br><span class="line">            <span class="comment">// 上式变形再代入可得y = x + 1 - dp[x] = i - dp[i - 1]；</span></span><br><span class="line">            <span class="comment">// 于是得到s[y]，如果s[y]和s[y-1]都是(，s[x]和s[x+1]都是 )，形如((...))，则合法</span></span><br><span class="line">            <span class="comment">// 其中省略号必然合法，因为该分支只会判断最近的一对合法的((...))，即只取局部最优解，对于该分支不合法的情况例如((())，(()))，由其他分支先处理或后处理；</span></span><br><span class="line">            <span class="comment">// 最后结果还要加上((...))之前的邻接合法子串长度，即dp[y-2]=dp[i-dp[i-1]-2]；</span></span><br><span class="line">            dp[i] = (dp[i - <span class="number">2</span> - dp[i - <span class="number">1</span>]] || <span class="number">0</span>) + dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/06/04/interview/interview-network/">前端面试题背诵纯享版（网络协议）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-06-04T07:10:05.000Z" itemprop="datePublished">2023-06-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h2><h3 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h3><p>TCP&#x2F;IP四层模型：应用、传输、网络、网络接口；</p>
<p>TCP&#x2F;IP五层模型（主流）：应用、传输、网络、数据链路、物理；</p>
<p>OSI七层模型：</p>
<ul>
<li>应用：http、ftp</li>
<li>表示：telnet</li>
<li>会话：dns</li>
<li>传输：udp、tcp</li>
<li>网络：ip</li>
<li>数据链路：以太网协议</li>
<li>物理；各种物理连接设备</li>
</ul>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p>2xx：</p>
<ul>
<li>200 OK</li>
<li>206 Partial Content</li>
</ul>
<p>3xx：</p>
<ul>
<li>301 Moved Permanently</li>
<li>304 Not Modified</li>
<li>307 Temporary Redirect，临时重定向，但新请求不能改变请求方法；</li>
<li>308 Permanent Redirect，永久重定向，但新请求不能改变请求方法；</li>
</ul>
<p>4xx：</p>
<ul>
<li>400 Bad Request，请求的语法有误；</li>
<li>403 Forbidden，服务器拒绝响应；</li>
<li>404 Not Found，请求的资源不存在；</li>
<li>405 Method Not Allowed，请求方法不合法；</li>
</ul>
<p>5xx：</p>
<ul>
<li>500 Internal Server Error</li>
<li>503 Service Unavailable，服务器宕机；</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是传输可靠、有连接、全双工的传输层协议；</p>
<h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><ol>
<li>C to S：SYN&#x3D;1，seq&#x3D;x；</li>
<li>S to C：SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1；</li>
<li>C to S：ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1；</li>
</ol>
<h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><ol>
<li>C to S：FIN&#x3D;1，seq&#x3D;u；</li>
<li>S to C：ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1，服务器继续发送旧数据；</li>
<li>S to C：FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;u+1，服务器停止发送任何数据；</li>
<li>C to S：ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1；</li>
</ol>
<p>第四次挥手后，客户端等待2MSL后再断开连接，否则如果服务器没有收到第四次挥手报文，将重复发送第三次挥手报文，由于此时客户端已经断开，服务器永远无法收到第四次挥手报文，将导致后续连接和数据包的混乱；</p>
<h3 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h3><p>确保双方同处于一个上下文中，使得信息同步，进而保证连接可靠性；</p>
<p>如果是一次握手，显然发起方不能确认连接是否成功建立；</p>
<p>如果是两次握手，接收方将无法确认发起方的第一次握手是否还有效，如果发起方第一次握手后放弃建立连接（非断开连接），客户端将无法感知到。</p>
<h3 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h3><p>相比三次握手，四次挥手多的是第二次挥手，这是因为第二次挥手是为了通知客户端还有旧数据要传输，传输完成后才可以说双方数据均以传输完毕，可以断开连接。</p>
<h3 id="TCP确保传输可靠的机制"><a href="#TCP确保传输可靠的机制" class="headerlink" title="TCP确保传输可靠的机制"></a>TCP确保传输可靠的机制</h3><ol>
<li>序列号和确认号；</li>
<li>超时重传；</li>
<li>流量控制；</li>
<li>拥塞控制；</li>
</ol>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>滑动窗口的大小使用<strong>慢启动</strong>动态改变，一旦发生丢包或超时则启动<strong>快速重传</strong>或<strong>快速恢复</strong>；</p>
<p>飞包守恒原则：总是收到一个旧包的ack确认包才会发送新包；</p>
<p>慢启动：</p>
<ul>
<li>维护一个拥塞窗口大小，初始为指定倍MSS（最大报文长度，双方协商的值），发送窗口大小取拥塞窗口与接受窗口的较小者，每1RTT拥塞窗口翻倍（每收到一个ack，大小加一）；</li>
<li>维护一个慢启动阈值，初始为<code>2^16 - 1</code>，一旦拥塞窗口超过该值，启动<strong>拥塞避免</strong>算法；</li>
<li>随着拥塞窗口指数级上升，到达阈值后变为线性上升，而一旦接收到三个相同ack，就会启动<strong>快速重传</strong>和<strong>快速恢复</strong>；</li>
</ul>
<p>超时重传：指定时间内没有收到ack确认包，重发超时的包；</p>
<p>冗余确认：发送的多个包，收到的却是相同的ack确认包（三个相同包），这时可以认定发生了丢包；</p>
<p>快速重传：确认丢包（冗余确认）后不必等待超时，立即重发丢失的包，之后启动<strong>快速恢复</strong>；</p>
<p>快速恢复：丢包后，先把阈值置为拥塞窗口的一半，继续发送数据，过程中使拥塞窗口尽量平滑地降低到阈值附近，然后退出快速恢复状态；</p>
<p>拥塞避免：拥塞窗口大小累加1MSS，开始线性增长。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="什么是UDP？"><a href="#什么是UDP？" class="headerlink" title="什么是UDP？"></a>什么是UDP？</h3><p>UDP是一种尽力交付但不保证交付、无连接、面向报文的传输层协议，支持一对一，一对多，多对多的通信；</p>
<p>不可靠是因为不具有TCP的拥塞控制、流量控制等机制；</p>
<p>面向报文是指UDP不会拆分、组合应用层的报文，加上UDP首部之后就会直接发送；</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>IP协议是无连接、不可靠的网络层协议，用于将数据从源地址发送到目的地址；</p>
<p>IP地址是一个32位的二进制数，由于MAC地址称为物理地址，所以IP地址也称逻辑地址，IP地址解决了网络中如何将数据传输到指定端的问题；</p>
<p>IP协议首部举例：</p>
<ul>
<li>源地址；</li>
<li>目的地址；</li>
<li>TTL：每经过一个设备就减一，为零时必须丢弃，避免找不到目的地址的IP数据包在网络中无限传播；</li>
<li>IP协议版本；</li>
<li>数据协议；</li>
<li>片偏移：数据包切分后用于标识偏移量；</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS是负责域名解析的会话层协议，由于IP地址不好记忆，所以可以注册一个域名来代替该IP地址，但由于IP协议不能直接识别域名，所以需要DNS协议从域名服务器获取到域名对应的IP地址；</p>
<p>DNS解析过程：先查询本地DNS服务器的缓存，本地DNS服务器如果没有记录，则依次查询根、顶级、二级域名服务器，直到查询到IP地址；</p>
<h2 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h2><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><h2 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h2><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h2 id="HTTP与浏览器缓存机制"><a href="#HTTP与浏览器缓存机制" class="headerlink" title="HTTP与浏览器缓存机制"></a>HTTP与浏览器缓存机制</h2><p>强缓存：由Catch-Control、Expires控制的缓存策略；</p>
<p>Catch-Control相关指令：</p>
<ul>
<li>如果不希望复用Response，使用no-store；</li>
<li>如果希望复用Response<ul>
<li>希望每次都验证资源有效性，使用no-catch；</li>
<li>不希望每次都验证<ul>
<li>允许中间服务器缓存，使用public；</li>
<li>（默认行为）不允许中间服务器缓存，使用private；</li>
</ul>
</li>
</ul>
</li>
<li>设置缓存有效时间，使用max-age&#x2F;s-max-age指令，优先级高于Expires首部；</li>
</ul>
<p>强缓存未命中的情况下，还有协商缓存策略：发送一条带有if-none-match&#x2F;if-modified-since首部的条件请求到源服务器，服务器验证资源有效性，有效则返回状态码304 Not Modified，失效则返回新资源，状态码200 OK;</p>
<p>注1：s-max-age可覆盖max-age和Expires，只能用于中间服务器缓存的时效控制；</p>
<p>注2：其他时效控制指令还有max-stale&#x2F;min-fresh等；</p>
<p>注3：private指令下，一般由浏览器本地缓存；</p>
<p>注4：if-match验证的是资源的ETag，if-modified-since验证的是资源的最近修改时间；</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>Cross-Origin Resource Sharing（跨域资源共享），包含一组扩展的HTTP首部，跨域的<code>简单请求</code>将直接发送，<code>非简单请求</code>将发送一个method为options的preflight请求；</p>
<p>请求首部：</p>
<ol>
<li>Access-Control-Request-Method</li>
<li>Access-Control-Request-Headers</li>
<li>Origin</li>
</ol>
<p>响应首部：</p>
<ol>
<li>Access-Control-Allow-Methods</li>
<li>Access-Control-Allow-Headers</li>
<li>Access-Control-Expose-Headers</li>
<li>Access-Control-Allow-Origin</li>
<li>Access-Control-Allow-Credentials</li>
<li>Access-Control-Max-Age</li>
</ol>
<p>简单请求：</p>
<ul>
<li>Method为Get&#x2F;Post&#x2F;Head；</li>
<li>仅包含以下首部：<ul>
<li>Other Auto-seted by user-agent headers（Connection&#x2F;User-Agent）；</li>
<li>Content-Type 仅包含：<ul>
<li>application&#x2F;x-www-form-urlencoded；</li>
<li>text&#x2F;plain；</li>
<li>multipart&#x2F;form-data；</li>
</ul>
</li>
<li>Accept；</li>
<li>Accept-Language；</li>
<li>Content-Language；</li>
<li>Content-Type；</li>
<li>DPR；</li>
<li>Downlink；</li>
<li>Save-Data；</li>
<li>Viewport-Width；</li>
<li>Width；</li>
</ul>
</li>
</ul>
<p>注：简单、非简单请求为过时的称呼，现行规范中不再使用；</p>
<p>流程：</p>
<ol>
<li>浏览器判断请求为：<ol>
<li>简单请求，直接发送该请求；</li>
<li>非简单请求，则<ol>
<li>发送preflight请求；</li>
<li>服务器响应该preflight请求；</li>
<li>发送真实请求；</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>简单请求只需要通过Origin和Access-Control-Allow-Origin就可以控制跨域资源的访问；<br>非简单请求还需要通过*-Request-Method\Headers和*-Request-Methods\Headers来控制跨域HTTP报文允许哪些Method和Header，*-Max-Age指定一段时间内无需再次发送preflight请求；</p>
<h2 id="跨域访问限制与解决方案"><a href="#跨域访问限制与解决方案" class="headerlink" title="跨域访问限制与解决方案"></a>跨域访问限制与解决方案</h2><p>通信双方的协议、域名和端口都相同，则称之为同源，否则就是不同源，不同源之间的通信称为跨域访问（跨源访问），浏览器对跨域访问有限制，为了解决该问题，有以下方案：</p>
<ol>
<li>CORS</li>
<li>Websocket：websocket不受跨域限制；</li>
<li>Jsonp：提前定义好回调函数，构建script元素，将跨域请求URL写入src，插入DOM，由于静态资源加载允许跨域，所以可以发送跨域请求，服务器在返回的js片段中编写回调函数的调用代码，并将服务器端的数据以回调函数参数的形式拼接进去。</li>
<li>正向代理、反向代理：确保客户端与代理服务器不跨域，由代理服务器与目标服务器通信，服务器之间通信自然不受浏览器的规则限制；</li>
<li>postMessage &amp; onmessage：用于不同源tab或iframe之间跨域通信，postMessage发送数据，onmessage监听数据接收事件；</li>
</ol>
<p>注：</p>
<ul>
<li>正向代理：向指定的客户端负责，任何这些客户端的请求，都通过该代理服务器代为发送；</li>
<li>反向代理：向指定的服务端负责，任何这些服务端的响应，都通过该代理服务器代为发送；</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP扩展首部：</p>
<ul>
<li>set-cookie：服务器在http响应报文中通过该首部通知浏览器设置cookie的值；</li>
<li>cookie：浏览器在http请求报文中通过该首部将cookie发送到服务器；</li>
<li>形式上如key&#x3D;value，多个键值对以分号<code>;</code>分隔；</li>
</ul>
<p>cookie指令：</p>
<ul>
<li>时效：<ul>
<li><code>Expires=&lt;date&gt;</code>：过期时间，默认为会话结束后过期；</li>
<li><code>Max-age=&lt;seconds&gt;</code>：有效时间，小于等于0将直接失效，优先级高于expires，兼容性差于expires；</li>
</ul>
</li>
<li>目标：<ul>
<li><code>Domain=&lt;domain&gt;</code>：指定访问哪些域需要携带cookie；</li>
<li><code>Path=&lt;path&gt;</code>：指定访问哪些资源路径（含所有子路径）需要携带cookie；</li>
</ul>
</li>
<li>安全：<ul>
<li><code>Secure</code>：只允许通过https携带cookie；</li>
<li><code>HttpOnly</code>：禁止js读写cookie；</li>
<li><code>SameSite=&lt;option&gt;</code>：B对A网站发起的请求是否允许携带A创建的cookie，可选项如下：<ul>
<li><code>strict</code>：完全禁止；</li>
<li><code>lax</code>：大部分禁止，只允许Get请求携带（超链接、Get表单、资源预加载）；</li>
<li><code>none</code>：不禁止；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注：浏览器禁止cookie跨域访问（读写），但允许跨域请求，即B不能读写A的cookie，但B对A可以发送请求，这个请求可以携带A的cookie，B相对于A来说是第三方网站，所以这个cookie也叫做第三方cookie，<strong>注意第三方cookie并不是第三方网站创建的cookie</strong>；</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/06/04/interview/interview-websecurity/">前端面试题背诵纯享版（网络安全）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-06-04T07:10:05.000Z" itemprop="datePublished">2023-06-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id=""><a href="#" class="headerlink" title=""></a></h2>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/06/01/interview/interview-ts-md/">前端面试题背诵纯享版（Typescript）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-06-01T07:10:05.000Z" itemprop="datePublished">2023-06-01</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="变型：协变、逆变、不变性"><a href="#变型：协变、逆变、不变性" class="headerlink" title="变型：协变、逆变、不变性"></a>变型：协变、逆变、不变性</h2><p><a target="_blank" rel="noopener" href="https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html#%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">讲的最好的协变、逆变</a></p>
<h2 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h2><p><code>T extends U ? T : never</code>，T如果可以分配给U，则返回类型T，否则返回never；</p>
<h2 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h2><p><code>T extends (a: infer R) =&gt; R ? R : never</code>，a的实际类型未知，用infer R先假设R是a的类型，有点类似于泛型，只不过推断类型是自动推断的，泛型需要传入泛型参数或预设默认值。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/05/31/react/react16-8code-md/">React16.8源码</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-05-31T07:13:51.000Z" itemprop="datePublished">2023-05-31</time>
</a>

            

        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h2><p>React Fiber是为了实现Virtual DOM的树结构，每个节点通return指向其父节点，sibling指向其兄弟节点，child指向其首个子节点，在Render和Commit阶段实际操作的就是React Fiber Tree，这种树的表示方式也称为树的<strong>孩子-兄弟表示法</strong>，这种表示法可将树转化为二叉树，左孩子就是首个子节点，右孩子就是首个兄弟节点，然后Fiber Tree的构建和Commit顺序就可以看作是二叉树的先根（序）遍历，不考虑这些的话，就是单纯的树的DFS.</p>
<p>React会维护两棵Fiber Tree，current对应当前页面，workInProgress对应正在处理、将要展示的页面，两棵树的节点之间互相通过alternate属性指向彼此，以便通过Diff算法得出节点变化，并在Commit阶段更新对应的浏览器DOM。</p>
<p>Fiber Node是以ReactElement为基础构建的。</p>
<p>Fiber Node还有一些其他属性：</p>
<ol>
<li>tag，标识组件类型；</li>
<li>stateNode，指向对应的浏览器DOM节点或者组件实例（ClassComponent）；</li>
<li>type，FunctionComponent指向对应函数，ClassComponent指向对应类，HostComponent存对应的HTML标签；</li>
<li>flags，存二进制数，用于记录Diff后对应的浏览器DOM需要做什么改变，取值Placement代表新增或替换，Deletion代表删除（<code>flags |= Deletion</code>增，<code>flags &amp;Deletion </code>验，<code>flags &amp;= ~Deletion</code>删）；</li>
<li>deletions，Diff后发现要删除的Fiber节点；</li>
<li>effectTag，副作用类型；</li>
<li>nextEffect，DFS顺序下，下一个有副作用的Fiber节点，构成一个单链表Effect List；</li>
<li>firstEffect，Effect List的头节点；</li>
<li>lastEffect，Effect List的尾节点；</li>
<li>lane，也是二进制数，表示Fiber Node的处理优先级，低优先级任务可能被打断，然后在下一次Reconcile处理（Reconcile就是Render+Commit）；</li>
</ol>
<h2 id="React-Update-Queue"><a href="#React-Update-Queue" class="headerlink" title="React Update Queue"></a>React Update Queue</h2><p>每个组件会维护一个update queue，所有</p>
<h2 id="React-Work-Loop"><a href="#React-Work-Loop" class="headerlink" title="React Work Loop"></a>React Work Loop</h2><h2 id="React-Lane"><a href="#React-Lane" class="headerlink" title="React Lane"></a>React Lane</h2><h2 id="React-Expiration-Time"><a href="#React-Expiration-Time" class="headerlink" title="React Expiration Time"></a>React Expiration Time</h2><h2 id="React-Scheduler"><a href="#React-Scheduler" class="headerlink" title="React Scheduler"></a>React Scheduler</h2><pre><code>render
    legacyRenderSubtreeIntoContainer
        legacyCreateRootFromDOMContainer
            createRoot
                new ReactDOMRoot
                    createRootImpl
                        createContainer 
                            createFiberRoot 
                                new FiberRootNode
                                    createHostRootFiber
                                        createFiber 
                                            new FiberNode
                                            initializeUpdateQueue
        unbatchedUpdates
            updateContainer
                requestEventTime
                requestUpdateLane
                getContextForSubtree
                createUpdate
                enqueueUpdate
                scheduleUpdateOnFiber !!!
                    markUpdateLaneFromFiberToRoot // 从当前节点到根节点，依次更新节点的Lane
                    markRootUpdated // 根节点标记为：存在pending update
                    performSyncWorkOnRoot !!!
                        getNextLanes
                        renderRootSync
                            prepareFreshStack // 初始化Work Loop必需的所有变量
                                createWorkInProgress
                                    createFiber
                                enqueueInterleavedUpdates
                            pushDispatcher // 设置一个ReactCurrentDispatcher，主要用于处理Hooks
                            workLoopSync !!!
                                performUnitOfWork
                                    beginWork !!! 沿child构建
                                        updateHostRoot !!!
                                            pushHostRootContext
                                            cloneUpdateQueue
                                            processUpdateQueue // 处理update queue，计算出最终state
                                            reconcileChildren
                                                mountChildFibers
                                                    reconcileChildFibers
                                                        placeSingleChild
                                                            reconcileSingleElement
                                    completeUnitOfWork !!! 
                                        completeWork
                            resetContextDependencies
                            popDispatcher // render结束，还原Dispatcher
                        commitRoot
                            commitRootImpl
                                commitBeforeMutationEffects !!! 1阶段，Before Mutation，执行生命周期函数
                                    prepareForCommit
                                    commitBeforeMutationEffects_begin
                                        commitBeforeMutationEffects_complete
                                            commitBeforeMutationEffectsOnFiber // 执行getSnapshotBeforeUpdate
                                commitMutationEffects !!! 2阶段，根据fiber.flags更新DOM
                                    commitMutationEffects_begin
                                        commitMutationEffects_complete
                                            commitDetachRef // 解除ref
                                            commitAttachRef // 重新设置ref
                                            commitPlacement
                                                insertOrAppendPlacementNodeIntoContainer // React DOM Api
                                                insertOrAppendPlacementNode // React DOM Api
                                            commitWork
                                                commitHookEffectListUnmount
                                                commitContainer
                                                    replaceContainerChildren // React DOM Api
                                commitLayoutEffects !!! 3阶段，执行layout
                                    commitLayoutEffects_begin // componentDidMount
                                        safelyCallCommitHookLayoutEffectListMount
                                            commitHookEffectListMount // HookLayout

                    ensureRootIsScheduled
                entangleTransitions
        getPublicRootInstance
</code></pre>
<p>setState</p>
<p>useState</p>
<p>useReducer</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/05/31/interview/interview-reactcode/">前端面试题背诵纯享版（React源码）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-05-31T07:11:19.000Z" itemprop="datePublished">2023-05-31</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="useState机制"><a href="#useState机制" class="headerlink" title="useState机制"></a>useState机制</h2><p>每个组件会维护一个<code>state对</code>数组，每次调用useState就向数组中添加一个<code>state对</code>，<code>state对</code>由state和setState函数组成，setState中维持对<code>state对</code>的引用，每个setState只能更新对应的state；</p>
<p>当组件挂载时，useState会创建<code>state对</code>，并将其加入<code>state对</code>数组，索引递增，指向下一个位置；</p>
<p>当组件更新时，索引置为0，再次调用useState只会移动<code>state对</code>数组的索引，并返回已经创建好的<code>state对</code>，因此，如果在if分支语句中使用useState，将可能导致useState返回错误的<code>state对</code>；</p>
<p>当调用<code>state对</code>的setState时，setState更新对应state的值，并调用React内部API，更新组件；</p>
<p>错误例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstRender = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (firstRender) &#123;</span><br><span class="line">        <span class="keyword">const</span> [name, setName] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;Neil&quot;</span>);</span><br><span class="line">        firstRender = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [gender， setGender] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;Male);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 首次挂载， 两次useState调用，state对 数组 like this</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    [&quot;</span><span class="title class_">Neil</span><span class="string">&quot;, setName],</span></span><br><span class="line"><span class="string">    [&quot;</span><span class="title class_">Male</span><span class="string">&quot;, setGender]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">// 组件更新，state对数组不变，但由于只有一次useState调用，索引初始为0，React.useState(&quot;</span><span class="title class_">Male</span><span class="string">&quot;)得到的state对是[&quot;</span><span class="title class_">Neil</span><span class="string">&quot;, setName]</span></span><br><span class="line"><span class="string">// 这就会导致setGender实际上修改的是name的值</span></span><br></pre></td></tr></table></figure>


        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/05/28/interview/interview-reactrouter/">前端面试题背诵纯享版（react-router）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-05-28T10:29:26.000Z" itemprop="datePublished">2023-05-28</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="客户端路由（CSR）原理"><a href="#客户端路由（CSR）原理" class="headerlink" title="客户端路由（CSR）原理"></a>客户端路由（CSR）原理</h2><p>传统浏览器导航行为就是URL改变时直接向服务器发送请求，服务器响应对应资源，而客户端路由就是URL改变时不再发送请求，而是由客户端部署的App自行匹配URL并展示对应内容。</p>
<p>remix&#x2F;history (v5.3)是react-router实现CSR的核心库，其中CSR分为两种：</p>
<ol>
<li>URL Hash</li>
<li>Browser History</li>
</ol>
<p><strong>编码式导航</strong>：二者都是通过history.pushState&#x2F;replaceState改变URL而不触发请求，只不过Hash路由中传递URL Hash，Browser history路由中传递URL；</p>
<p><strong>浏览器交互式导航</strong>（如back、forward或手动输入URL）：浏览器发起的导航通过<code>popstate, hashchange</code>事件来监听，进而触发所有listener，具体如下：</p>
<ol>
<li>Hash：通过popstate事件来监听URL Hash变化，由于IE11中URL Hash改变不会触发popstate事件，所以也会监听hashchange事件；</li>
<li>Browser history：通过popstate事件来监听URL变化；</li>
</ol>
<p>react-router v6新增<code>&lt;RouterProvider&gt;</code>组件，该组件订阅了URL的改变，URL改变时更新react state，触发app的重新渲染；</p>
<h2 id="react-router-v5路由嵌套原理"><a href="#react-router-v5路由嵌套原理" class="headerlink" title="react-router v5路由嵌套原理"></a>react-router v5路由嵌套原理</h2><p><code>Route</code>是对<code>RouterContext.Consumer</code>与<code>RouterContext.Provider</code>的封装，该组件会获取最近的<code>RouterContext.Provider</code>的context value，并创建新的<code>RouterContext.Provider</code>，以便子路由获取其context value，这就实现了路由嵌套。</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2023/05/19/interview/interview-mobx/">前端面试题背诵纯享版（Mobx）</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://neil-ji.github.io/page/2/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-05-19T06:31:16.000Z" itemprop="datePublished">2023-05-19</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="Mobx简介"><a href="#Mobx简介" class="headerlink" title="Mobx简介"></a>Mobx简介</h2><ul>
<li>非单一数据源</li>
<li>单向数据流</li>
</ul>
<h2 id="Mobx核心概念"><a href="#Mobx核心概念" class="headerlink" title="Mobx核心概念"></a>Mobx核心概念</h2><ul>
<li>State</li>
<li>Action</li>
<li>Derivation<ul>
<li>Computed value：是一个无参纯函数，输入相同时将直接返回上次缓存的值</li>
<li>Reaction：当State改变时，需要执行的副作用</li>
</ul>
</li>
</ul>
<h2 id="Mobx数据流"><a href="#Mobx数据流" class="headerlink" title="Mobx数据流"></a>Mobx数据流</h2><p><img src="https://www.mobxjs.com/assets/images/action-state-view-c1db5d4253bd84302606d4dfed9c4eb2.png" alt="Mobx数据流"></p>
<p>通过action改变state，进而触发derivation更新</p>
<h2 id="Mobx-observer"><a href="#Mobx-observer" class="headerlink" title="Mobx observer"></a>Mobx observer</h2><p>observer是一个HOC，当可观测State改变时<strong>负责重渲染传入的组件</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">observer</span>(<span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">&#123;someObservableState&#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="使状态可观测"><a href="#使状态可观测" class="headerlink" title="使状态可观测"></a>使状态可观测</h2><ol>
<li>observable</li>
<li>makeObservable</li>
<li>makeAutoObservable</li>
</ol>
<p>注：</p>
<ul>
<li>observable用于不能使原始值、实例变为可观测；</li>
<li>observable作为函数可单独使用，也可以在类中作为注解或make*第二参数中的标记使用；</li>
<li>makeObservable和makeAutoObservable只能在类中使用；</li>
<li>makeAutoObservable不能在子类中使用；</li>
</ul>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">observable</span>(&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> increase = <span class="title function_">action</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    store.<span class="property">value</span>++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注解（装饰器语法，截至2023年5月25日，尚未成为ES标准）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line">    @observable value</span><br><span class="line">    @action (v) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeObservable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Doubler</span> &#123;</span><br><span class="line">    value</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">            <span class="attr">value</span>: observable,</span><br><span class="line">            <span class="attr">double</span>: computed,</span><br><span class="line">            <span class="attr">increment</span>: action,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">double</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span>++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeAutoObservable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Doubler</span> &#123;</span><br><span class="line">    value</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 更方便、简洁</span></span><br><span class="line">        <span class="title function_">makeObservable</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">double</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span>++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="observable与make-的区别"><a href="#observable与make-的区别" class="headerlink" title="observable与make*的区别"></a>observable与make*的区别</h2><ul>
<li>observable不改变传入的对象，而是克隆该对象再转换为可观察对象；make*改变传入的对象，直接将其转换为可观察对象；</li>
<li>observable使用Proxy实现对象代理，make*</li>
</ul>
<h2 id="Mobx-action"><a href="#Mobx-action" class="headerlink" title="Mobx action"></a>Mobx action</h2><ul>
<li>action是改变可观察state的唯一方式；</li>
<li>action是纯函数；</li>
<li>action在transactions内执行，因而是同步的，期间不完整的state是不能获取到的（原子性）；</li>
<li>嵌套的action会合并在一个事务中；</li>
<li>平行的action会各自产生一个事务；</li>
<li>只有定义在原型上的action可被子类覆盖；</li>
</ul>
<p>action.bound用于正确绑定this指针，避免字面量方式定义的对象在使用时this指向错误对象，可以代替箭头函数；</p>
<h2 id="Mobx-异步action"><a href="#Mobx-异步action" class="headerlink" title="Mobx 异步action"></a>Mobx 异步action</h2><ol>
<li>基本方式：异步操作的回调中需要改变state时，要包装为action；</li>
<li>runInAction方式：在runInAction中改变state，是基本方式的简化；</li>
<li>flow方式：将异步操作定义在generator function中，并将其标记为flow，mobx会负责generator的自动执行，并将其包装成Promise；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本</span></span><br><span class="line"><span class="keyword">async</span> fetchA () &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(...);</span><br><span class="line">    <span class="title function_">action</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = data;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runInAction</span></span><br><span class="line"><span class="keyword">async</span> fetchA () &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(...);</span><br><span class="line">    <span class="title function_">runInAction</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flow</span></span><br><span class="line">@flow</span><br><span class="line">* <span class="title function_">fetchA</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> <span class="title function_">fetch</span>(...);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = data;</span><br><span class="line">    &#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>makeAutoObservable会自动将生成器函数标记为flow；</li>
<li>flow返回的Promise被添加了一个cancel()，用于取消生成器的执行，但try、finally仍会执行；</li>
</ul>
<h2 id="Mobx-computed-value"><a href="#Mobx-computed-value" class="headerlink" title="Mobx computed value"></a>Mobx computed value</h2><ul>
<li>惰性求值；</li>
<li>输出会被缓存，依赖的可观察对象改变时，才会重新求值；</li>
<li>未被观察时将暂时停用；</li>
</ul>
<p>computed做注解或函数使用时都可以传入options对象，其中比较有价值的一个属性是equals，用于控制如何比较输出是否相等，除了自定义比较函数以外，mobx内置了四种比较方式：</p>
<ol>
<li>comparer.identity，即全等号<code>===</code>；</li>
<li>comparer.default，除了NaN等于NaN，其他与comparer.identity相同；</li>
<li>comparer.shallow，浅比较；</li>
<li>comparer.structural，结构比较；</li>
</ol>
<p>其余属性：</p>
<ol>
<li>name，用于debug时提供一个有意义的标识；</li>
<li>requiresReaction，为昂贵计算设为true；</li>
<li>keepAlive，设为true则未被观察时也不会停用；</li>
</ol>
<p>注：2、3实际应用场景暂不清楚。</p>
<h2 id="Mobx-reaction"><a href="#Mobx-reaction" class="headerlink" title="Mobx reaction"></a>Mobx reaction</h2><p>可观测对象变化时，reaction用于执行副作用，简单来说就是执行一些不纯的函数，例如日志打印。</p>
<ol>
<li>autorun((reaction) &#x3D;&gt; effect, options?)</li>
<li>reaction(() &#x3D;&gt; data, (data, preData, reaction) &#x3D;&gt; effect, options?)</li>
<li>when<ol>
<li>when(predicate: () &#x3D;&gt; boolean, effect?: () &#x3D;&gt; void, options?)</li>
<li>when(predicate: () &#x3D;&gt; boolean, options?): Promise</li>
</ol>
</li>
</ol>
<p>以上三个api都会监测可观测对象，当可观测对象改变时执行副作用，并各自提供了一种方式清理掉副作用；</p>
<p>总结一下Reaction就是以某种方式实现三种行为：</p>
<ol>
<li>监测（或订阅、消费）可观测对象；</li>
<li>可观测对象改变时执行副作用；</li>
<li>清理副作用；</li>
</ol>
<p>autorun，第一个参数实现1和2，该参数的参数是一个reaction对象，reaction.dispose实现3，<strong>会在初始时执行一次</strong>；</p>
<p>reaction，第一个参数实现1，第二个参数实现2，第二参数的reaction参数实现3；</p>
<p>when，第一个参数实现1和3，predicate的Boolean返回值会被监测，返回true时自动执行并清理副作用，第二个参数实现2，未提供时返回一个Promise，通过Promise.cancel手动清理副作用；</p>
<p>根据执行时机的不同：</p>
<ul>
<li>autorun初始时执行一次，之后每当观测值改变都将再次执行；</li>
<li>when在条件为true时执行一次副作用；</li>
<li>reaction初始时不执行，之后每当观测值改变都将再次执行；</li>
</ul>
<p>注：Reactions和Computed Value的一个重要区别就是是否产生新的值，避免滥用Reactions！</p>

        
    </section>
</article>




<nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
</nav>



            </div>
        </div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    

</body>
</html>
